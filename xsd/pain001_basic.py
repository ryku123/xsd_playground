#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Mar 21 16:46:10 2016 by generateDS.py version 2.20a.
#
# Command line options:
#   ('-o', 'pain001_basic.py')
#   ('-s', 'pain001_sub.py')
#   ('--super', 'pain001')
#
# Command line arguments:
#   pain.001.001.03.ch.02.xsd
#
# Command line:
#   c:\Python27\Scripts\generateDS.py -o "pain001_basic.py" -s "pain001_basicSub.py" --super="pain001_basic" pain.001.001.03.ch.02.xsd
#
# Current working directory (os.getcwd()):
#   xsd
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class AccountIdentification4Choice_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IBAN=None, Othr=None):
        self.original_tagname_ = None
        self.IBAN = IBAN
        self.validate_IBAN2007Identifier(self.IBAN)
        self.Othr = Othr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountIdentification4Choice_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountIdentification4Choice_CH.subclass:
            return AccountIdentification4Choice_CH.subclass(*args_, **kwargs_)
        else:
            return AccountIdentification4Choice_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IBAN(self): return self.IBAN
    def set_IBAN(self, IBAN): self.IBAN = IBAN
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def validate_IBAN2007Identifier(self, value):
        # Validate type IBAN2007Identifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IBAN2007Identifier_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IBAN2007Identifier_patterns_, ))
    validate_IBAN2007Identifier_patterns_ = [['^[A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30}$']]
    def hasContent_(self):
        if (
            self.IBAN is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountIdentification4Choice-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountIdentification4Choice-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountIdentification4Choice-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountIdentification4Choice-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AccountIdentification4Choice-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IBAN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIBAN>%s</%sIBAN>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.IBAN), input_name='IBAN')), namespace_, eol_))
        if self.Othr is not None:
            self.Othr.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IBAN':
            IBAN_ = child_.text
            IBAN_ = self.gds_validate_string(IBAN_, node, 'IBAN')
            self.IBAN = IBAN_
            # validate type IBAN2007Identifier
            self.validate_IBAN2007Identifier(self.IBAN)
        elif nodeName_ == 'Othr':
            obj_ = GenericAccountIdentification1_CH.factory()
            obj_.build(child_)
            self.Othr = obj_
            obj_.original_tagname_ = 'Othr'
# end class AccountIdentification4Choice_CH


class ActiveOrHistoricCurrencyAndAmount(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Ccy=None, valueOf_=None):
        self.original_tagname_ = None
        self.Ccy = _cast(None, Ccy)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveOrHistoricCurrencyAndAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveOrHistoricCurrencyAndAmount.subclass:
            return ActiveOrHistoricCurrencyAndAmount.subclass(*args_, **kwargs_)
        else:
            return ActiveOrHistoricCurrencyAndAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ccy(self): return self.Ccy
    def set_Ccy(self, Ccy): self.Ccy = Ccy
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_ActiveOrHistoricCurrencyCode(self, value):
        # Validate type ActiveOrHistoricCurrencyCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ActiveOrHistoricCurrencyCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ActiveOrHistoricCurrencyCode_patterns_, ))
    validate_ActiveOrHistoricCurrencyCode_patterns_ = [['^[A-Z]{3,3}$']]
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveOrHistoricCurrencyAndAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveOrHistoricCurrencyAndAmount')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveOrHistoricCurrencyAndAmount', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveOrHistoricCurrencyAndAmount'):
        if self.Ccy is not None and 'Ccy' not in already_processed:
            already_processed.add('Ccy')
            outfile.write(' Ccy=%s' % (quote_attrib(self.Ccy), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveOrHistoricCurrencyAndAmount', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Ccy', node)
        if value is not None and 'Ccy' not in already_processed:
            already_processed.add('Ccy')
            self.Ccy = value
            self.validate_ActiveOrHistoricCurrencyCode(self.Ccy)    # validate type ActiveOrHistoricCurrencyCode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActiveOrHistoricCurrencyAndAmount


class AmountType3Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InstdAmt=None, EqvtAmt=None):
        self.original_tagname_ = None
        self.InstdAmt = InstdAmt
        self.EqvtAmt = EqvtAmt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountType3Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountType3Choice.subclass:
            return AmountType3Choice.subclass(*args_, **kwargs_)
        else:
            return AmountType3Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InstdAmt(self): return self.InstdAmt
    def set_InstdAmt(self, InstdAmt): self.InstdAmt = InstdAmt
    def get_EqvtAmt(self): return self.EqvtAmt
    def set_EqvtAmt(self, EqvtAmt): self.EqvtAmt = EqvtAmt
    def hasContent_(self):
        if (
            self.InstdAmt is not None or
            self.EqvtAmt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmountType3Choice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountType3Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmountType3Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmountType3Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AmountType3Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InstdAmt is not None:
            self.InstdAmt.export(outfile, level, namespace_, name_='InstdAmt', pretty_print=pretty_print)
        if self.EqvtAmt is not None:
            self.EqvtAmt.export(outfile, level, namespace_, name_='EqvtAmt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InstdAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.InstdAmt = obj_
            obj_.original_tagname_ = 'InstdAmt'
        elif nodeName_ == 'EqvtAmt':
            obj_ = EquivalentAmount2.factory()
            obj_.build(child_)
            self.EqvtAmt = obj_
            obj_.original_tagname_ = 'EqvtAmt'
# end class AmountType3Choice


class BranchAndFinancialInstitutionIdentification4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FinInstnId=None, BrnchId=None):
        self.original_tagname_ = None
        self.FinInstnId = FinInstnId
        self.BrnchId = BrnchId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BranchAndFinancialInstitutionIdentification4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BranchAndFinancialInstitutionIdentification4.subclass:
            return BranchAndFinancialInstitutionIdentification4.subclass(*args_, **kwargs_)
        else:
            return BranchAndFinancialInstitutionIdentification4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FinInstnId(self): return self.FinInstnId
    def set_FinInstnId(self, FinInstnId): self.FinInstnId = FinInstnId
    def get_BrnchId(self): return self.BrnchId
    def set_BrnchId(self, BrnchId): self.BrnchId = BrnchId
    def hasContent_(self):
        if (
            self.FinInstnId is not None or
            self.BrnchId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BranchAndFinancialInstitutionIdentification4', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BranchAndFinancialInstitutionIdentification4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BranchAndFinancialInstitutionIdentification4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BranchAndFinancialInstitutionIdentification4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BranchAndFinancialInstitutionIdentification4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FinInstnId is not None:
            self.FinInstnId.export(outfile, level, namespace_, name_='FinInstnId', pretty_print=pretty_print)
        if self.BrnchId is not None:
            self.BrnchId.export(outfile, level, namespace_, name_='BrnchId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FinInstnId':
            obj_ = FinancialInstitutionIdentification7.factory()
            obj_.build(child_)
            self.FinInstnId = obj_
            obj_.original_tagname_ = 'FinInstnId'
        elif nodeName_ == 'BrnchId':
            obj_ = BranchData2.factory()
            obj_.build(child_)
            self.BrnchId = obj_
            obj_.original_tagname_ = 'BrnchId'
# end class BranchAndFinancialInstitutionIdentification4


class BranchAndFinancialInstitutionIdentification4_CH_BicOrClrId(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FinInstnId=None):
        self.original_tagname_ = None
        self.FinInstnId = FinInstnId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BranchAndFinancialInstitutionIdentification4_CH_BicOrClrId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BranchAndFinancialInstitutionIdentification4_CH_BicOrClrId.subclass:
            return BranchAndFinancialInstitutionIdentification4_CH_BicOrClrId.subclass(*args_, **kwargs_)
        else:
            return BranchAndFinancialInstitutionIdentification4_CH_BicOrClrId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FinInstnId(self): return self.FinInstnId
    def set_FinInstnId(self, FinInstnId): self.FinInstnId = FinInstnId
    def hasContent_(self):
        if (
            self.FinInstnId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BranchAndFinancialInstitutionIdentification4-CH_BicOrClrId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BranchAndFinancialInstitutionIdentification4-CH_BicOrClrId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BranchAndFinancialInstitutionIdentification4-CH_BicOrClrId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BranchAndFinancialInstitutionIdentification4-CH_BicOrClrId'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BranchAndFinancialInstitutionIdentification4-CH_BicOrClrId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FinInstnId is not None:
            self.FinInstnId.export(outfile, level, namespace_, name_='FinInstnId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FinInstnId':
            obj_ = FinancialInstitutionIdentification7_CH_BicOrClrId.factory()
            obj_.build(child_)
            self.FinInstnId = obj_
            obj_.original_tagname_ = 'FinInstnId'
# end class BranchAndFinancialInstitutionIdentification4_CH_BicOrClrId


class BranchAndFinancialInstitutionIdentification4_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FinInstnId=None):
        self.original_tagname_ = None
        self.FinInstnId = FinInstnId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BranchAndFinancialInstitutionIdentification4_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BranchAndFinancialInstitutionIdentification4_CH.subclass:
            return BranchAndFinancialInstitutionIdentification4_CH.subclass(*args_, **kwargs_)
        else:
            return BranchAndFinancialInstitutionIdentification4_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FinInstnId(self): return self.FinInstnId
    def set_FinInstnId(self, FinInstnId): self.FinInstnId = FinInstnId
    def hasContent_(self):
        if (
            self.FinInstnId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BranchAndFinancialInstitutionIdentification4-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BranchAndFinancialInstitutionIdentification4-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BranchAndFinancialInstitutionIdentification4-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BranchAndFinancialInstitutionIdentification4-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BranchAndFinancialInstitutionIdentification4-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FinInstnId is not None:
            self.FinInstnId.export(outfile, level, namespace_, name_='FinInstnId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FinInstnId':
            obj_ = FinancialInstitutionIdentification7_CH.factory()
            obj_.build(child_)
            self.FinInstnId = obj_
            obj_.original_tagname_ = 'FinInstnId'
# end class BranchAndFinancialInstitutionIdentification4_CH


class BranchData2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, Nm=None, PstlAdr=None):
        self.original_tagname_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.PstlAdr = PstlAdr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BranchData2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BranchData2.subclass:
            return BranchData2.subclass(*args_, **kwargs_)
        else:
            return BranchData2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_PstlAdr(self): return self.PstlAdr
    def set_PstlAdr(self, PstlAdr): self.PstlAdr = PstlAdr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max140Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max140Text_patterns_, ))
    validate_Max140Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Nm is not None or
            self.PstlAdr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BranchData2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BranchData2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BranchData2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BranchData2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BranchData2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
        if self.Nm is not None:
            self.Nm.export(outfile, level, namespace_, name_='Nm', pretty_print=pretty_print)
        if self.PstlAdr is not None:
            self.PstlAdr.export(outfile, level, namespace_, name_='PstlAdr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            obj_ = None
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'Nm':
            obj_ = None
            self.Nm = obj_
            obj_.original_tagname_ = 'Nm'
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress6.factory()
            obj_.build(child_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
# end class BranchData2


class CashAccount16_CH_IdAndCurrency(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, Ccy=None):
        self.original_tagname_ = None
        self.Id = Id
        self.Ccy = Ccy
        self.validate_ActiveOrHistoricCurrencyCode(self.Ccy)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashAccount16_CH_IdAndCurrency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashAccount16_CH_IdAndCurrency.subclass:
            return CashAccount16_CH_IdAndCurrency.subclass(*args_, **kwargs_)
        else:
            return CashAccount16_CH_IdAndCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Ccy(self): return self.Ccy
    def set_Ccy(self, Ccy): self.Ccy = Ccy
    def validate_ActiveOrHistoricCurrencyCode(self, value):
        # Validate type ActiveOrHistoricCurrencyCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ActiveOrHistoricCurrencyCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ActiveOrHistoricCurrencyCode_patterns_, ))
    validate_ActiveOrHistoricCurrencyCode_patterns_ = [['^[A-Z]{3,3}$']]
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Ccy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashAccount16-CH_IdAndCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashAccount16-CH_IdAndCurrency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashAccount16-CH_IdAndCurrency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashAccount16-CH_IdAndCurrency'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CashAccount16-CH_IdAndCurrency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
        if self.Ccy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCcy>%s</%sCcy>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ccy), input_name='Ccy')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            obj_ = AccountIdentification4Choice_CH.factory()
            obj_.build(child_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Ccy':
            Ccy_ = child_.text
            Ccy_ = self.gds_validate_string(Ccy_, node, 'Ccy')
            self.Ccy = Ccy_
            # validate type ActiveOrHistoricCurrencyCode
            self.validate_ActiveOrHistoricCurrencyCode(self.Ccy)
# end class CashAccount16_CH_IdAndCurrency


class CashAccount16_CH_IdTpCcy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, Tp=None, Ccy=None):
        self.original_tagname_ = None
        self.Id = Id
        self.Tp = Tp
        self.Ccy = Ccy
        self.validate_ActiveOrHistoricCurrencyCode(self.Ccy)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashAccount16_CH_IdTpCcy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashAccount16_CH_IdTpCcy.subclass:
            return CashAccount16_CH_IdTpCcy.subclass(*args_, **kwargs_)
        else:
            return CashAccount16_CH_IdTpCcy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Tp(self): return self.Tp
    def set_Tp(self, Tp): self.Tp = Tp
    def get_Ccy(self): return self.Ccy
    def set_Ccy(self, Ccy): self.Ccy = Ccy
    def validate_ActiveOrHistoricCurrencyCode(self, value):
        # Validate type ActiveOrHistoricCurrencyCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ActiveOrHistoricCurrencyCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ActiveOrHistoricCurrencyCode_patterns_, ))
    validate_ActiveOrHistoricCurrencyCode_patterns_ = [['^[A-Z]{3,3}$']]
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Tp is not None or
            self.Ccy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashAccount16-CH_IdTpCcy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashAccount16-CH_IdTpCcy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashAccount16-CH_IdTpCcy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashAccount16-CH_IdTpCcy'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CashAccount16-CH_IdTpCcy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
        if self.Tp is not None:
            self.Tp.export(outfile, level, namespace_, name_='Tp', pretty_print=pretty_print)
        if self.Ccy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCcy>%s</%sCcy>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ccy), input_name='Ccy')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            obj_ = AccountIdentification4Choice_CH.factory()
            obj_.build(child_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Tp':
            obj_ = CashAccountType2.factory()
            obj_.build(child_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Ccy':
            Ccy_ = child_.text
            Ccy_ = self.gds_validate_string(Ccy_, node, 'Ccy')
            self.Ccy = Ccy_
            # validate type ActiveOrHistoricCurrencyCode
            self.validate_ActiveOrHistoricCurrencyCode(self.Ccy)
# end class CashAccount16_CH_IdTpCcy


class CashAccount16_CH_Id(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None):
        self.original_tagname_ = None
        self.Id = Id
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashAccount16_CH_Id)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashAccount16_CH_Id.subclass:
            return CashAccount16_CH_Id.subclass(*args_, **kwargs_)
        else:
            return CashAccount16_CH_Id(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.Id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashAccount16-CH_Id', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashAccount16-CH_Id')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashAccount16-CH_Id', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashAccount16-CH_Id'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CashAccount16-CH_Id', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            obj_ = AccountIdentification4Choice_CH.factory()
            obj_.build(child_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
# end class CashAccount16_CH_Id


class CashAccountType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_CashAccountType4Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashAccountType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashAccountType2.subclass:
            return CashAccountType2.subclass(*args_, **kwargs_)
        else:
            return CashAccountType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_CashAccountType4Code(self, value):
        # Validate type CashAccountType4Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CASH', 'CHAR', 'COMM', 'TAXE', 'CISH', 'TRAS', 'SACC', 'CACC', 'SVGS', 'ONDP', 'MGLD', 'NREX', 'MOMA', 'LOAN', 'SLRY', 'ODFT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CashAccountType4Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashAccountType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashAccountType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashAccountType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashAccountType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CashAccountType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            self.Prtry.export(outfile, level, namespace_, name_='Prtry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type CashAccountType4Code
            self.validate_CashAccountType4Code(self.Cd)
        elif nodeName_ == 'Prtry':
            obj_ = None
            self.Prtry = obj_
            obj_.original_tagname_ = 'Prtry'
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class CashAccountType2


class CategoryPurpose1_CH_Code(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalCategoryPurpose1Code(self.Cd)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryPurpose1_CH_Code)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryPurpose1_CH_Code.subclass:
            return CategoryPurpose1_CH_Code.subclass(*args_, **kwargs_)
        else:
            return CategoryPurpose1_CH_Code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def validate_ExternalCategoryPurpose1Code(self, value):
        # Validate type ExternalCategoryPurpose1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalCategoryPurpose1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalCategoryPurpose1Code' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CategoryPurpose1-CH_Code', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategoryPurpose1-CH_Code')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CategoryPurpose1-CH_Code', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CategoryPurpose1-CH_Code'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CategoryPurpose1-CH_Code', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalCategoryPurpose1Code
            self.validate_ExternalCategoryPurpose1Code(self.Cd)
# end class CategoryPurpose1_CH_Code


class Cheque6_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChqTp=None, DlvryMtd=None):
        self.original_tagname_ = None
        self.ChqTp = ChqTp
        self.validate_ChequeType2Code(self.ChqTp)
        self.DlvryMtd = DlvryMtd
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cheque6_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cheque6_CH.subclass:
            return Cheque6_CH.subclass(*args_, **kwargs_)
        else:
            return Cheque6_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChqTp(self): return self.ChqTp
    def set_ChqTp(self, ChqTp): self.ChqTp = ChqTp
    def get_DlvryMtd(self): return self.DlvryMtd
    def set_DlvryMtd(self, DlvryMtd): self.DlvryMtd = DlvryMtd
    def validate_ChequeType2Code(self, value):
        # Validate type ChequeType2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CCHQ', 'CCCH', 'BCHQ', 'DRFT', 'ELDR']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChequeType2Code' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ChqTp is not None or
            self.DlvryMtd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Cheque6-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cheque6-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Cheque6-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cheque6-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Cheque6-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChqTp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChqTp>%s</%sChqTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChqTp), input_name='ChqTp')), namespace_, eol_))
        if self.DlvryMtd is not None:
            self.DlvryMtd.export(outfile, level, namespace_, name_='DlvryMtd', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChqTp':
            ChqTp_ = child_.text
            ChqTp_ = self.gds_validate_string(ChqTp_, node, 'ChqTp')
            self.ChqTp = ChqTp_
            # validate type ChequeType2Code
            self.validate_ChequeType2Code(self.ChqTp)
        elif nodeName_ == 'DlvryMtd':
            obj_ = ChequeDeliveryMethod1Choice.factory()
            obj_.build(child_)
            self.DlvryMtd = obj_
            obj_.original_tagname_ = 'DlvryMtd'
# end class Cheque6_CH


class ChequeDeliveryMethod1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ChequeDelivery1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChequeDeliveryMethod1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChequeDeliveryMethod1Choice.subclass:
            return ChequeDeliveryMethod1Choice.subclass(*args_, **kwargs_)
        else:
            return ChequeDeliveryMethod1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ChequeDelivery1Code(self, value):
        # Validate type ChequeDelivery1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MLDB', 'MLCD', 'MLFA', 'CRDB', 'CRCD', 'CRFA', 'PUDB', 'PUCD', 'PUFA', 'RGDB', 'RGCD', 'RGFA']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChequeDelivery1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChequeDeliveryMethod1Choice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChequeDeliveryMethod1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChequeDeliveryMethod1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChequeDeliveryMethod1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChequeDeliveryMethod1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            self.Prtry.export(outfile, level, namespace_, name_='Prtry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ChequeDelivery1Code
            self.validate_ChequeDelivery1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            obj_ = None
            self.Prtry = obj_
            obj_.original_tagname_ = 'Prtry'
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ChequeDeliveryMethod1Choice


class ClearingSystemIdentification2Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalClearingSystemIdentification1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearingSystemIdentification2Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearingSystemIdentification2Choice.subclass:
            return ClearingSystemIdentification2Choice.subclass(*args_, **kwargs_)
        else:
            return ClearingSystemIdentification2Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalClearingSystemIdentification1Code(self, value):
        # Validate type ExternalClearingSystemIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalClearingSystemIdentification1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalClearingSystemIdentification1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClearingSystemIdentification2Choice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClearingSystemIdentification2Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClearingSystemIdentification2Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClearingSystemIdentification2Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ClearingSystemIdentification2Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            self.Prtry.export(outfile, level, namespace_, name_='Prtry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalClearingSystemIdentification1Code
            self.validate_ExternalClearingSystemIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            obj_ = None
            self.Prtry = obj_
            obj_.original_tagname_ = 'Prtry'
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ClearingSystemIdentification2Choice


class ClearingSystemMemberIdentification2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClrSysId=None, MmbId=None):
        self.original_tagname_ = None
        self.ClrSysId = ClrSysId
        self.MmbId = MmbId
        self.validate_Max35Text(self.MmbId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearingSystemMemberIdentification2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearingSystemMemberIdentification2.subclass:
            return ClearingSystemMemberIdentification2.subclass(*args_, **kwargs_)
        else:
            return ClearingSystemMemberIdentification2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClrSysId(self): return self.ClrSysId
    def set_ClrSysId(self, ClrSysId): self.ClrSysId = ClrSysId
    def get_MmbId(self): return self.MmbId
    def set_MmbId(self, MmbId): self.MmbId = MmbId
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.ClrSysId is not None or
            self.MmbId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClearingSystemMemberIdentification2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClearingSystemMemberIdentification2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClearingSystemMemberIdentification2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClearingSystemMemberIdentification2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ClearingSystemMemberIdentification2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClrSysId is not None:
            self.ClrSysId.export(outfile, level, namespace_, name_='ClrSysId', pretty_print=pretty_print)
        if self.MmbId is not None:
            self.MmbId.export(outfile, level, namespace_, name_='MmbId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClrSysId':
            obj_ = ClearingSystemIdentification2Choice.factory()
            obj_.build(child_)
            self.ClrSysId = obj_
            obj_.original_tagname_ = 'ClrSysId'
        elif nodeName_ == 'MmbId':
            obj_ = None
            self.MmbId = obj_
            obj_.original_tagname_ = 'MmbId'
            # validate type Max35Text
            self.validate_Max35Text(self.MmbId)
# end class ClearingSystemMemberIdentification2


class ContactDetails2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NmPrfx=None, Nm=None, PhneNb=None, MobNb=None, FaxNb=None, EmailAdr=None, Othr=None):
        self.original_tagname_ = None
        self.NmPrfx = NmPrfx
        self.validate_NamePrefix1Code(self.NmPrfx)
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.PhneNb = PhneNb
        self.validate_PhoneNumber(self.PhneNb)
        self.MobNb = MobNb
        self.validate_PhoneNumber(self.MobNb)
        self.FaxNb = FaxNb
        self.validate_PhoneNumber(self.FaxNb)
        self.EmailAdr = EmailAdr
        self.validate_Max2048Text(self.EmailAdr)
        self.Othr = Othr
        self.validate_Max35Text(self.Othr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactDetails2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactDetails2.subclass:
            return ContactDetails2.subclass(*args_, **kwargs_)
        else:
            return ContactDetails2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NmPrfx(self): return self.NmPrfx
    def set_NmPrfx(self, NmPrfx): self.NmPrfx = NmPrfx
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_PhneNb(self): return self.PhneNb
    def set_PhneNb(self, PhneNb): self.PhneNb = PhneNb
    def get_MobNb(self): return self.MobNb
    def set_MobNb(self, MobNb): self.MobNb = MobNb
    def get_FaxNb(self): return self.FaxNb
    def set_FaxNb(self, FaxNb): self.FaxNb = FaxNb
    def get_EmailAdr(self): return self.EmailAdr
    def set_EmailAdr(self, EmailAdr): self.EmailAdr = EmailAdr
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def validate_NamePrefix1Code(self, value):
        # Validate type NamePrefix1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DOCT', 'MIST', 'MISS', 'MADM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NamePrefix1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max140Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max140Text_patterns_, ))
    validate_Max140Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_PhoneNumber(self, value):
        # Validate type PhoneNumber, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PhoneNumber_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PhoneNumber_patterns_, ))
    validate_PhoneNumber_patterns_ = [['^\\+[0-9]{1,3}-[0-9()+\\-]{1,30}$']]
    def validate_Max2048Text(self, value):
        # Validate type Max2048Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2048:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max2048Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max2048Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max2048Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max2048Text_patterns_, ))
    validate_Max2048Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.NmPrfx is not None or
            self.Nm is not None or
            self.PhneNb is not None or
            self.MobNb is not None or
            self.FaxNb is not None or
            self.EmailAdr is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContactDetails2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactDetails2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContactDetails2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactDetails2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactDetails2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NmPrfx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNmPrfx>%s</%sNmPrfx>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NmPrfx), input_name='NmPrfx')), namespace_, eol_))
        if self.Nm is not None:
            self.Nm.export(outfile, level, namespace_, name_='Nm', pretty_print=pretty_print)
        if self.PhneNb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhneNb>%s</%sPhneNb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PhneNb), input_name='PhneNb')), namespace_, eol_))
        if self.MobNb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMobNb>%s</%sMobNb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MobNb), input_name='MobNb')), namespace_, eol_))
        if self.FaxNb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFaxNb>%s</%sFaxNb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FaxNb), input_name='FaxNb')), namespace_, eol_))
        if self.EmailAdr is not None:
            self.EmailAdr.export(outfile, level, namespace_, name_='EmailAdr', pretty_print=pretty_print)
        if self.Othr is not None:
            self.Othr.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NmPrfx':
            NmPrfx_ = child_.text
            NmPrfx_ = self.gds_validate_string(NmPrfx_, node, 'NmPrfx')
            self.NmPrfx = NmPrfx_
            # validate type NamePrefix1Code
            self.validate_NamePrefix1Code(self.NmPrfx)
        elif nodeName_ == 'Nm':
            obj_ = None
            self.Nm = obj_
            obj_.original_tagname_ = 'Nm'
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PhneNb':
            PhneNb_ = child_.text
            PhneNb_ = self.gds_validate_string(PhneNb_, node, 'PhneNb')
            self.PhneNb = PhneNb_
            # validate type PhoneNumber
            self.validate_PhoneNumber(self.PhneNb)
        elif nodeName_ == 'MobNb':
            MobNb_ = child_.text
            MobNb_ = self.gds_validate_string(MobNb_, node, 'MobNb')
            self.MobNb = MobNb_
            # validate type PhoneNumber
            self.validate_PhoneNumber(self.MobNb)
        elif nodeName_ == 'FaxNb':
            FaxNb_ = child_.text
            FaxNb_ = self.gds_validate_string(FaxNb_, node, 'FaxNb')
            self.FaxNb = FaxNb_
            # validate type PhoneNumber
            self.validate_PhoneNumber(self.FaxNb)
        elif nodeName_ == 'EmailAdr':
            obj_ = None
            self.EmailAdr = obj_
            obj_.original_tagname_ = 'EmailAdr'
            # validate type Max2048Text
            self.validate_Max2048Text(self.EmailAdr)
        elif nodeName_ == 'Othr':
            obj_ = None
            self.Othr = obj_
            obj_.original_tagname_ = 'Othr'
            # validate type Max35Text
            self.validate_Max35Text(self.Othr)
# end class ContactDetails2


class ContactDetails2_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Nm=None, Othr=None):
        self.original_tagname_ = None
        self.Nm = Nm
        self.validate_Max70Text(self.Nm)
        self.Othr = Othr
        self.validate_Max35Text(self.Othr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactDetails2_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactDetails2_CH.subclass:
            return ContactDetails2_CH.subclass(*args_, **kwargs_)
        else:
            return ContactDetails2_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def validate_Max70Text(self, value):
        # Validate type Max70Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max70Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max70Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max70Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max70Text_patterns_, ))
    validate_Max70Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Nm is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContactDetails2-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactDetails2-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContactDetails2-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactDetails2-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactDetails2-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            self.Nm.export(outfile, level, namespace_, name_='Nm', pretty_print=pretty_print)
        if self.Othr is not None:
            self.Othr.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nm':
            obj_ = None
            self.Nm = obj_
            obj_.original_tagname_ = 'Nm'
            # validate type Max70Text
            self.validate_Max70Text(self.Nm)
        elif nodeName_ == 'Othr':
            obj_ = None
            self.Othr = obj_
            obj_.original_tagname_ = 'Othr'
            # validate type Max35Text
            self.validate_Max35Text(self.Othr)
# end class ContactDetails2_CH


class CreditTransferTransactionInformation10_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PmtId=None, PmtTpInf=None, Amt=None, XchgRateInf=None, ChrgBr=None, ChqInstr=None, UltmtDbtr=None, IntrmyAgt1=None, CdtrAgt=None, Cdtr=None, CdtrAcct=None, UltmtCdtr=None, InstrForCdtrAgt=None, InstrForDbtrAgt=None, Purp=None, RgltryRptg=None, RmtInf=None):
        self.original_tagname_ = None
        self.PmtId = PmtId
        self.PmtTpInf = PmtTpInf
        self.Amt = Amt
        self.XchgRateInf = XchgRateInf
        self.ChrgBr = ChrgBr
        self.validate_ChargeBearerType1Code(self.ChrgBr)
        self.ChqInstr = ChqInstr
        self.UltmtDbtr = UltmtDbtr
        self.IntrmyAgt1 = IntrmyAgt1
        self.CdtrAgt = CdtrAgt
        self.Cdtr = Cdtr
        self.CdtrAcct = CdtrAcct
        self.UltmtCdtr = UltmtCdtr
        if InstrForCdtrAgt is None:
            self.InstrForCdtrAgt = []
        else:
            self.InstrForCdtrAgt = InstrForCdtrAgt
        self.InstrForDbtrAgt = InstrForDbtrAgt
        self.validate_Max140Text(self.InstrForDbtrAgt)
        self.Purp = Purp
        if RgltryRptg is None:
            self.RgltryRptg = []
        else:
            self.RgltryRptg = RgltryRptg
        self.RmtInf = RmtInf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditTransferTransactionInformation10_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditTransferTransactionInformation10_CH.subclass:
            return CreditTransferTransactionInformation10_CH.subclass(*args_, **kwargs_)
        else:
            return CreditTransferTransactionInformation10_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PmtId(self): return self.PmtId
    def set_PmtId(self, PmtId): self.PmtId = PmtId
    def get_PmtTpInf(self): return self.PmtTpInf
    def set_PmtTpInf(self, PmtTpInf): self.PmtTpInf = PmtTpInf
    def get_Amt(self): return self.Amt
    def set_Amt(self, Amt): self.Amt = Amt
    def get_XchgRateInf(self): return self.XchgRateInf
    def set_XchgRateInf(self, XchgRateInf): self.XchgRateInf = XchgRateInf
    def get_ChrgBr(self): return self.ChrgBr
    def set_ChrgBr(self, ChrgBr): self.ChrgBr = ChrgBr
    def get_ChqInstr(self): return self.ChqInstr
    def set_ChqInstr(self, ChqInstr): self.ChqInstr = ChqInstr
    def get_UltmtDbtr(self): return self.UltmtDbtr
    def set_UltmtDbtr(self, UltmtDbtr): self.UltmtDbtr = UltmtDbtr
    def get_IntrmyAgt1(self): return self.IntrmyAgt1
    def set_IntrmyAgt1(self, IntrmyAgt1): self.IntrmyAgt1 = IntrmyAgt1
    def get_CdtrAgt(self): return self.CdtrAgt
    def set_CdtrAgt(self, CdtrAgt): self.CdtrAgt = CdtrAgt
    def get_Cdtr(self): return self.Cdtr
    def set_Cdtr(self, Cdtr): self.Cdtr = Cdtr
    def get_CdtrAcct(self): return self.CdtrAcct
    def set_CdtrAcct(self, CdtrAcct): self.CdtrAcct = CdtrAcct
    def get_UltmtCdtr(self): return self.UltmtCdtr
    def set_UltmtCdtr(self, UltmtCdtr): self.UltmtCdtr = UltmtCdtr
    def get_InstrForCdtrAgt(self): return self.InstrForCdtrAgt
    def set_InstrForCdtrAgt(self, InstrForCdtrAgt): self.InstrForCdtrAgt = InstrForCdtrAgt
    def add_InstrForCdtrAgt(self, value): self.InstrForCdtrAgt.append(value)
    def insert_InstrForCdtrAgt_at(self, index, value): self.InstrForCdtrAgt.insert(index, value)
    def replace_InstrForCdtrAgt_at(self, index, value): self.InstrForCdtrAgt[index] = value
    def get_InstrForDbtrAgt(self): return self.InstrForDbtrAgt
    def set_InstrForDbtrAgt(self, InstrForDbtrAgt): self.InstrForDbtrAgt = InstrForDbtrAgt
    def get_Purp(self): return self.Purp
    def set_Purp(self, Purp): self.Purp = Purp
    def get_RgltryRptg(self): return self.RgltryRptg
    def set_RgltryRptg(self, RgltryRptg): self.RgltryRptg = RgltryRptg
    def add_RgltryRptg(self, value): self.RgltryRptg.append(value)
    def insert_RgltryRptg_at(self, index, value): self.RgltryRptg.insert(index, value)
    def replace_RgltryRptg_at(self, index, value): self.RgltryRptg[index] = value
    def get_RmtInf(self): return self.RmtInf
    def set_RmtInf(self, RmtInf): self.RmtInf = RmtInf
    def validate_ChargeBearerType1Code(self, value):
        # Validate type ChargeBearerType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEBT', 'CRED', 'SHAR', 'SLEV']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChargeBearerType1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max140Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max140Text_patterns_, ))
    validate_Max140Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.PmtId is not None or
            self.PmtTpInf is not None or
            self.Amt is not None or
            self.XchgRateInf is not None or
            self.ChrgBr is not None or
            self.ChqInstr is not None or
            self.UltmtDbtr is not None or
            self.IntrmyAgt1 is not None or
            self.CdtrAgt is not None or
            self.Cdtr is not None or
            self.CdtrAcct is not None or
            self.UltmtCdtr is not None or
            self.InstrForCdtrAgt or
            self.InstrForDbtrAgt is not None or
            self.Purp is not None or
            self.RgltryRptg or
            self.RmtInf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditTransferTransactionInformation10-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditTransferTransactionInformation10-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditTransferTransactionInformation10-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditTransferTransactionInformation10-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditTransferTransactionInformation10-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PmtId is not None:
            self.PmtId.export(outfile, level, namespace_, name_='PmtId', pretty_print=pretty_print)
        if self.PmtTpInf is not None:
            self.PmtTpInf.export(outfile, level, namespace_, name_='PmtTpInf', pretty_print=pretty_print)
        if self.Amt is not None:
            self.Amt.export(outfile, level, namespace_, name_='Amt', pretty_print=pretty_print)
        if self.XchgRateInf is not None:
            self.XchgRateInf.export(outfile, level, namespace_, name_='XchgRateInf', pretty_print=pretty_print)
        if self.ChrgBr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChrgBr>%s</%sChrgBr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChrgBr), input_name='ChrgBr')), namespace_, eol_))
        if self.ChqInstr is not None:
            self.ChqInstr.export(outfile, level, namespace_, name_='ChqInstr', pretty_print=pretty_print)
        if self.UltmtDbtr is not None:
            self.UltmtDbtr.export(outfile, level, namespace_, name_='UltmtDbtr', pretty_print=pretty_print)
        if self.IntrmyAgt1 is not None:
            self.IntrmyAgt1.export(outfile, level, namespace_, name_='IntrmyAgt1', pretty_print=pretty_print)
        if self.CdtrAgt is not None:
            self.CdtrAgt.export(outfile, level, namespace_, name_='CdtrAgt', pretty_print=pretty_print)
        if self.Cdtr is not None:
            self.Cdtr.export(outfile, level, namespace_, name_='Cdtr', pretty_print=pretty_print)
        if self.CdtrAcct is not None:
            self.CdtrAcct.export(outfile, level, namespace_, name_='CdtrAcct', pretty_print=pretty_print)
        if self.UltmtCdtr is not None:
            self.UltmtCdtr.export(outfile, level, namespace_, name_='UltmtCdtr', pretty_print=pretty_print)
        for InstrForCdtrAgt_ in self.InstrForCdtrAgt:
            InstrForCdtrAgt_.export(outfile, level, namespace_, name_='InstrForCdtrAgt', pretty_print=pretty_print)
        if self.InstrForDbtrAgt is not None:
            self.InstrForDbtrAgt.export(outfile, level, namespace_, name_='InstrForDbtrAgt', pretty_print=pretty_print)
        if self.Purp is not None:
            self.Purp.export(outfile, level, namespace_, name_='Purp', pretty_print=pretty_print)
        for RgltryRptg_ in self.RgltryRptg:
            RgltryRptg_.export(outfile, level, namespace_, name_='RgltryRptg', pretty_print=pretty_print)
        if self.RmtInf is not None:
            self.RmtInf.export(outfile, level, namespace_, name_='RmtInf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PmtId':
            obj_ = PaymentIdentification1.factory()
            obj_.build(child_)
            self.PmtId = obj_
            obj_.original_tagname_ = 'PmtId'
        elif nodeName_ == 'PmtTpInf':
            obj_ = PaymentTypeInformation19_CH.factory()
            obj_.build(child_)
            self.PmtTpInf = obj_
            obj_.original_tagname_ = 'PmtTpInf'
        elif nodeName_ == 'Amt':
            obj_ = AmountType3Choice.factory()
            obj_.build(child_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
        elif nodeName_ == 'XchgRateInf':
            obj_ = ExchangeRateInformation1.factory()
            obj_.build(child_)
            self.XchgRateInf = obj_
            obj_.original_tagname_ = 'XchgRateInf'
        elif nodeName_ == 'ChrgBr':
            ChrgBr_ = child_.text
            ChrgBr_ = self.gds_validate_string(ChrgBr_, node, 'ChrgBr')
            self.ChrgBr = ChrgBr_
            # validate type ChargeBearerType1Code
            self.validate_ChargeBearerType1Code(self.ChrgBr)
        elif nodeName_ == 'ChqInstr':
            obj_ = Cheque6_CH.factory()
            obj_.build(child_)
            self.ChqInstr = obj_
            obj_.original_tagname_ = 'ChqInstr'
        elif nodeName_ == 'UltmtDbtr':
            obj_ = PartyIdentification32_CH.factory()
            obj_.build(child_)
            self.UltmtDbtr = obj_
            obj_.original_tagname_ = 'UltmtDbtr'
        elif nodeName_ == 'IntrmyAgt1':
            obj_ = BranchAndFinancialInstitutionIdentification4_CH.factory()
            obj_.build(child_)
            self.IntrmyAgt1 = obj_
            obj_.original_tagname_ = 'IntrmyAgt1'
        elif nodeName_ == 'CdtrAgt':
            obj_ = BranchAndFinancialInstitutionIdentification4_CH.factory()
            obj_.build(child_)
            self.CdtrAgt = obj_
            obj_.original_tagname_ = 'CdtrAgt'
        elif nodeName_ == 'Cdtr':
            obj_ = PartyIdentification32_CH_Name.factory()
            obj_.build(child_)
            self.Cdtr = obj_
            obj_.original_tagname_ = 'Cdtr'
        elif nodeName_ == 'CdtrAcct':
            obj_ = CashAccount16_CH_Id.factory()
            obj_.build(child_)
            self.CdtrAcct = obj_
            obj_.original_tagname_ = 'CdtrAcct'
        elif nodeName_ == 'UltmtCdtr':
            obj_ = PartyIdentification32_CH_Name.factory()
            obj_.build(child_)
            self.UltmtCdtr = obj_
            obj_.original_tagname_ = 'UltmtCdtr'
        elif nodeName_ == 'InstrForCdtrAgt':
            obj_ = InstructionForCreditorAgent1.factory()
            obj_.build(child_)
            self.InstrForCdtrAgt.append(obj_)
            obj_.original_tagname_ = 'InstrForCdtrAgt'
        elif nodeName_ == 'InstrForDbtrAgt':
            obj_ = None
            self.InstrForDbtrAgt = obj_
            obj_.original_tagname_ = 'InstrForDbtrAgt'
            # validate type Max140Text
            self.validate_Max140Text(self.InstrForDbtrAgt)
        elif nodeName_ == 'Purp':
            obj_ = Purpose2_CH_Code.factory()
            obj_.build(child_)
            self.Purp = obj_
            obj_.original_tagname_ = 'Purp'
        elif nodeName_ == 'RgltryRptg':
            obj_ = RegulatoryReporting3.factory()
            obj_.build(child_)
            self.RgltryRptg.append(obj_)
            obj_.original_tagname_ = 'RgltryRptg'
        elif nodeName_ == 'RmtInf':
            obj_ = RemittanceInformation5_CH.factory()
            obj_.build(child_)
            self.RmtInf = obj_
            obj_.original_tagname_ = 'RmtInf'
# end class CreditTransferTransactionInformation10_CH


class CreditorReferenceInformation2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Ref=None):
        self.original_tagname_ = None
        self.Tp = Tp
        self.Ref = Ref
        self.validate_Max35Text(self.Ref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditorReferenceInformation2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditorReferenceInformation2.subclass:
            return CreditorReferenceInformation2.subclass(*args_, **kwargs_)
        else:
            return CreditorReferenceInformation2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tp(self): return self.Tp
    def set_Tp(self, Tp): self.Tp = Tp
    def get_Ref(self): return self.Ref
    def set_Ref(self, Ref): self.Ref = Ref
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Tp is not None or
            self.Ref is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditorReferenceInformation2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditorReferenceInformation2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditorReferenceInformation2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditorReferenceInformation2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditorReferenceInformation2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            self.Tp.export(outfile, level, namespace_, name_='Tp', pretty_print=pretty_print)
        if self.Ref is not None:
            self.Ref.export(outfile, level, namespace_, name_='Ref', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tp':
            obj_ = CreditorReferenceType2.factory()
            obj_.build(child_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Ref':
            obj_ = None
            self.Ref = obj_
            obj_.original_tagname_ = 'Ref'
            # validate type Max35Text
            self.validate_Max35Text(self.Ref)
# end class CreditorReferenceInformation2


class CreditorReferenceType1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_DocumentType3Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditorReferenceType1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditorReferenceType1Choice.subclass:
            return CreditorReferenceType1Choice.subclass(*args_, **kwargs_)
        else:
            return CreditorReferenceType1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_DocumentType3Code(self, value):
        # Validate type DocumentType3Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['RADM', 'RPIN', 'FXDR', 'DISP', 'PUOR', 'SCOR']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DocumentType3Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditorReferenceType1Choice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditorReferenceType1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditorReferenceType1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditorReferenceType1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditorReferenceType1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            self.Prtry.export(outfile, level, namespace_, name_='Prtry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type DocumentType3Code
            self.validate_DocumentType3Code(self.Cd)
        elif nodeName_ == 'Prtry':
            obj_ = None
            self.Prtry = obj_
            obj_.original_tagname_ = 'Prtry'
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class CreditorReferenceType1Choice


class CreditorReferenceType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CdOrPrtry=None, Issr=None):
        self.original_tagname_ = None
        self.CdOrPrtry = CdOrPrtry
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditorReferenceType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditorReferenceType2.subclass:
            return CreditorReferenceType2.subclass(*args_, **kwargs_)
        else:
            return CreditorReferenceType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CdOrPrtry(self): return self.CdOrPrtry
    def set_CdOrPrtry(self, CdOrPrtry): self.CdOrPrtry = CdOrPrtry
    def get_Issr(self): return self.Issr
    def set_Issr(self, Issr): self.Issr = Issr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.CdOrPrtry is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditorReferenceType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditorReferenceType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditorReferenceType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditorReferenceType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditorReferenceType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CdOrPrtry is not None:
            self.CdOrPrtry.export(outfile, level, namespace_, name_='CdOrPrtry', pretty_print=pretty_print)
        if self.Issr is not None:
            self.Issr.export(outfile, level, namespace_, name_='Issr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CdOrPrtry':
            obj_ = CreditorReferenceType1Choice.factory()
            obj_.build(child_)
            self.CdOrPrtry = obj_
            obj_.original_tagname_ = 'CdOrPrtry'
        elif nodeName_ == 'Issr':
            obj_ = None
            self.Issr = obj_
            obj_.original_tagname_ = 'Issr'
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class CreditorReferenceType2


class CustomerCreditTransferInitiationV03_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GrpHdr=None, PmtInf=None):
        self.original_tagname_ = None
        self.GrpHdr = GrpHdr
        if PmtInf is None:
            self.PmtInf = []
        else:
            self.PmtInf = PmtInf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerCreditTransferInitiationV03_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerCreditTransferInitiationV03_CH.subclass:
            return CustomerCreditTransferInitiationV03_CH.subclass(*args_, **kwargs_)
        else:
            return CustomerCreditTransferInitiationV03_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GrpHdr(self): return self.GrpHdr
    def set_GrpHdr(self, GrpHdr): self.GrpHdr = GrpHdr
    def get_PmtInf(self): return self.PmtInf
    def set_PmtInf(self, PmtInf): self.PmtInf = PmtInf
    def add_PmtInf(self, value): self.PmtInf.append(value)
    def insert_PmtInf_at(self, index, value): self.PmtInf.insert(index, value)
    def replace_PmtInf_at(self, index, value): self.PmtInf[index] = value
    def hasContent_(self):
        if (
            self.GrpHdr is not None or
            self.PmtInf
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomerCreditTransferInitiationV03-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerCreditTransferInitiationV03-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomerCreditTransferInitiationV03-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomerCreditTransferInitiationV03-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomerCreditTransferInitiationV03-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GrpHdr is not None:
            self.GrpHdr.export(outfile, level, namespace_, name_='GrpHdr', pretty_print=pretty_print)
        for PmtInf_ in self.PmtInf:
            PmtInf_.export(outfile, level, namespace_, name_='PmtInf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GrpHdr':
            obj_ = GroupHeader32_CH.factory()
            obj_.build(child_)
            self.GrpHdr = obj_
            obj_.original_tagname_ = 'GrpHdr'
        elif nodeName_ == 'PmtInf':
            obj_ = PaymentInstructionInformation3_CH.factory()
            obj_.build(child_)
            self.PmtInf.append(obj_)
            obj_.original_tagname_ = 'PmtInf'
# end class CustomerCreditTransferInitiationV03_CH


class DateAndPlaceOfBirth(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BirthDt=None, PrvcOfBirth=None, CityOfBirth=None, CtryOfBirth=None):
        self.original_tagname_ = None
        if isinstance(BirthDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(BirthDt, '%Y-%m-%d').date()
        else:
            initvalue_ = BirthDt
        self.BirthDt = initvalue_
        self.PrvcOfBirth = PrvcOfBirth
        self.validate_Max35Text(self.PrvcOfBirth)
        self.CityOfBirth = CityOfBirth
        self.validate_Max35Text(self.CityOfBirth)
        self.CtryOfBirth = CtryOfBirth
        self.validate_CountryCode(self.CtryOfBirth)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateAndPlaceOfBirth)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateAndPlaceOfBirth.subclass:
            return DateAndPlaceOfBirth.subclass(*args_, **kwargs_)
        else:
            return DateAndPlaceOfBirth(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BirthDt(self): return self.BirthDt
    def set_BirthDt(self, BirthDt): self.BirthDt = BirthDt
    def get_PrvcOfBirth(self): return self.PrvcOfBirth
    def set_PrvcOfBirth(self, PrvcOfBirth): self.PrvcOfBirth = PrvcOfBirth
    def get_CityOfBirth(self): return self.CityOfBirth
    def set_CityOfBirth(self, CityOfBirth): self.CityOfBirth = CityOfBirth
    def get_CtryOfBirth(self): return self.CtryOfBirth
    def set_CtryOfBirth(self, CtryOfBirth): self.CtryOfBirth = CtryOfBirth
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CountryCode_patterns_, ))
    validate_CountryCode_patterns_ = [['^[A-Z]{2,2}$']]
    def hasContent_(self):
        if (
            self.BirthDt is not None or
            self.PrvcOfBirth is not None or
            self.CityOfBirth is not None or
            self.CtryOfBirth is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateAndPlaceOfBirth', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateAndPlaceOfBirth')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateAndPlaceOfBirth', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateAndPlaceOfBirth'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateAndPlaceOfBirth', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BirthDt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBirthDt>%s</%sBirthDt>%s' % (namespace_, self.gds_format_date(self.BirthDt, input_name='BirthDt'), namespace_, eol_))
        if self.PrvcOfBirth is not None:
            self.PrvcOfBirth.export(outfile, level, namespace_, name_='PrvcOfBirth', pretty_print=pretty_print)
        if self.CityOfBirth is not None:
            self.CityOfBirth.export(outfile, level, namespace_, name_='CityOfBirth', pretty_print=pretty_print)
        if self.CtryOfBirth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtryOfBirth>%s</%sCtryOfBirth>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CtryOfBirth), input_name='CtryOfBirth')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BirthDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.BirthDt = dval_
            # validate type ISODate
            self.validate_ISODate(self.BirthDt)
        elif nodeName_ == 'PrvcOfBirth':
            obj_ = None
            self.PrvcOfBirth = obj_
            obj_.original_tagname_ = 'PrvcOfBirth'
            # validate type Max35Text
            self.validate_Max35Text(self.PrvcOfBirth)
        elif nodeName_ == 'CityOfBirth':
            obj_ = None
            self.CityOfBirth = obj_
            obj_.original_tagname_ = 'CityOfBirth'
            # validate type Max35Text
            self.validate_Max35Text(self.CityOfBirth)
        elif nodeName_ == 'CtryOfBirth':
            CtryOfBirth_ = child_.text
            CtryOfBirth_ = self.gds_validate_string(CtryOfBirth_, node, 'CtryOfBirth')
            self.CtryOfBirth = CtryOfBirth_
            # validate type CountryCode
            self.validate_CountryCode(self.CtryOfBirth)
# end class DateAndPlaceOfBirth


class Document(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CstmrCdtTrfInitn=None):
        self.original_tagname_ = None
        self.CstmrCdtTrfInitn = CstmrCdtTrfInitn
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Document)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Document.subclass:
            return Document.subclass(*args_, **kwargs_)
        else:
            return Document(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CstmrCdtTrfInitn(self): return self.CstmrCdtTrfInitn
    def set_CstmrCdtTrfInitn(self, CstmrCdtTrfInitn): self.CstmrCdtTrfInitn = CstmrCdtTrfInitn
    def hasContent_(self):
        if (
            self.CstmrCdtTrfInitn is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Document', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Document')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Document', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Document'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Document', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CstmrCdtTrfInitn is not None:
            self.CstmrCdtTrfInitn.export(outfile, level, namespace_, name_='CstmrCdtTrfInitn', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CstmrCdtTrfInitn':
            obj_ = CustomerCreditTransferInitiationV03_CH.factory()
            obj_.build(child_)
            self.CstmrCdtTrfInitn = obj_
            obj_.original_tagname_ = 'CstmrCdtTrfInitn'
# end class Document


class DocumentAdjustment1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Amt=None, CdtDbtInd=None, Rsn=None, AddtlInf=None):
        self.original_tagname_ = None
        self.Amt = Amt
        self.CdtDbtInd = CdtDbtInd
        self.validate_CreditDebitCode(self.CdtDbtInd)
        self.Rsn = Rsn
        self.validate_Max4Text(self.Rsn)
        self.AddtlInf = AddtlInf
        self.validate_Max140Text(self.AddtlInf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentAdjustment1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentAdjustment1.subclass:
            return DocumentAdjustment1.subclass(*args_, **kwargs_)
        else:
            return DocumentAdjustment1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Amt(self): return self.Amt
    def set_Amt(self, Amt): self.Amt = Amt
    def get_CdtDbtInd(self): return self.CdtDbtInd
    def set_CdtDbtInd(self, CdtDbtInd): self.CdtDbtInd = CdtDbtInd
    def get_Rsn(self): return self.Rsn
    def set_Rsn(self, Rsn): self.Rsn = Rsn
    def get_AddtlInf(self): return self.AddtlInf
    def set_AddtlInf(self, AddtlInf): self.AddtlInf = AddtlInf
    def validate_CreditDebitCode(self, value):
        # Validate type CreditDebitCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CRDT', 'DBIT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CreditDebitCode' % {"value" : value.encode("utf-8")} )
    def validate_Max4Text(self, value):
        # Validate type Max4Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max4Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max4Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max4Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max4Text_patterns_, ))
    validate_Max4Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max140Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max140Text_patterns_, ))
    validate_Max140Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Amt is not None or
            self.CdtDbtInd is not None or
            self.Rsn is not None or
            self.AddtlInf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DocumentAdjustment1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentAdjustment1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DocumentAdjustment1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocumentAdjustment1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DocumentAdjustment1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Amt is not None:
            self.Amt.export(outfile, level, namespace_, name_='Amt', pretty_print=pretty_print)
        if self.CdtDbtInd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCdtDbtInd>%s</%sCdtDbtInd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CdtDbtInd), input_name='CdtDbtInd')), namespace_, eol_))
        if self.Rsn is not None:
            self.Rsn.export(outfile, level, namespace_, name_='Rsn', pretty_print=pretty_print)
        if self.AddtlInf is not None:
            self.AddtlInf.export(outfile, level, namespace_, name_='AddtlInf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
        elif nodeName_ == 'CdtDbtInd':
            CdtDbtInd_ = child_.text
            CdtDbtInd_ = self.gds_validate_string(CdtDbtInd_, node, 'CdtDbtInd')
            self.CdtDbtInd = CdtDbtInd_
            # validate type CreditDebitCode
            self.validate_CreditDebitCode(self.CdtDbtInd)
        elif nodeName_ == 'Rsn':
            obj_ = None
            self.Rsn = obj_
            obj_.original_tagname_ = 'Rsn'
            # validate type Max4Text
            self.validate_Max4Text(self.Rsn)
        elif nodeName_ == 'AddtlInf':
            obj_ = None
            self.AddtlInf = obj_
            obj_.original_tagname_ = 'AddtlInf'
            # validate type Max140Text
            self.validate_Max140Text(self.AddtlInf)
# end class DocumentAdjustment1


class EquivalentAmount2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Amt=None, CcyOfTrf=None):
        self.original_tagname_ = None
        self.Amt = Amt
        self.CcyOfTrf = CcyOfTrf
        self.validate_ActiveOrHistoricCurrencyCode(self.CcyOfTrf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EquivalentAmount2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EquivalentAmount2.subclass:
            return EquivalentAmount2.subclass(*args_, **kwargs_)
        else:
            return EquivalentAmount2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Amt(self): return self.Amt
    def set_Amt(self, Amt): self.Amt = Amt
    def get_CcyOfTrf(self): return self.CcyOfTrf
    def set_CcyOfTrf(self, CcyOfTrf): self.CcyOfTrf = CcyOfTrf
    def validate_ActiveOrHistoricCurrencyCode(self, value):
        # Validate type ActiveOrHistoricCurrencyCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ActiveOrHistoricCurrencyCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ActiveOrHistoricCurrencyCode_patterns_, ))
    validate_ActiveOrHistoricCurrencyCode_patterns_ = [['^[A-Z]{3,3}$']]
    def hasContent_(self):
        if (
            self.Amt is not None or
            self.CcyOfTrf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EquivalentAmount2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EquivalentAmount2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EquivalentAmount2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EquivalentAmount2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EquivalentAmount2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Amt is not None:
            self.Amt.export(outfile, level, namespace_, name_='Amt', pretty_print=pretty_print)
        if self.CcyOfTrf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCcyOfTrf>%s</%sCcyOfTrf>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CcyOfTrf), input_name='CcyOfTrf')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
        elif nodeName_ == 'CcyOfTrf':
            CcyOfTrf_ = child_.text
            CcyOfTrf_ = self.gds_validate_string(CcyOfTrf_, node, 'CcyOfTrf')
            self.CcyOfTrf = CcyOfTrf_
            # validate type ActiveOrHistoricCurrencyCode
            self.validate_ActiveOrHistoricCurrencyCode(self.CcyOfTrf)
# end class EquivalentAmount2


class ExchangeRateInformation1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, XchgRate=None, RateTp=None, CtrctId=None):
        self.original_tagname_ = None
        self.XchgRate = XchgRate
        self.validate_BaseOneRate(self.XchgRate)
        self.RateTp = RateTp
        self.validate_ExchangeRateType1Code(self.RateTp)
        self.CtrctId = CtrctId
        self.validate_Max35Text(self.CtrctId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeRateInformation1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeRateInformation1.subclass:
            return ExchangeRateInformation1.subclass(*args_, **kwargs_)
        else:
            return ExchangeRateInformation1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XchgRate(self): return self.XchgRate
    def set_XchgRate(self, XchgRate): self.XchgRate = XchgRate
    def get_RateTp(self): return self.RateTp
    def set_RateTp(self, RateTp): self.RateTp = RateTp
    def get_CtrctId(self): return self.CtrctId
    def set_CtrctId(self, CtrctId): self.CtrctId = CtrctId
    def validate_BaseOneRate(self, value):
        # Validate type BaseOneRate, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on BaseOneRate' % {"value" : value} )
    def validate_ExchangeRateType1Code(self, value):
        # Validate type ExchangeRateType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SPOT', 'SALE', 'AGRD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExchangeRateType1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.XchgRate is not None or
            self.RateTp is not None or
            self.CtrctId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeRateInformation1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeRateInformation1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeRateInformation1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeRateInformation1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeRateInformation1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.XchgRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sXchgRate>%s</%sXchgRate>%s' % (namespace_, self.gds_format_float(self.XchgRate, input_name='XchgRate'), namespace_, eol_))
        if self.RateTp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRateTp>%s</%sRateTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RateTp), input_name='RateTp')), namespace_, eol_))
        if self.CtrctId is not None:
            self.CtrctId.export(outfile, level, namespace_, name_='CtrctId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XchgRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'XchgRate')
            self.XchgRate = fval_
            # validate type BaseOneRate
            self.validate_BaseOneRate(self.XchgRate)
        elif nodeName_ == 'RateTp':
            RateTp_ = child_.text
            RateTp_ = self.gds_validate_string(RateTp_, node, 'RateTp')
            self.RateTp = RateTp_
            # validate type ExchangeRateType1Code
            self.validate_ExchangeRateType1Code(self.RateTp)
        elif nodeName_ == 'CtrctId':
            obj_ = None
            self.CtrctId = obj_
            obj_.original_tagname_ = 'CtrctId'
            # validate type Max35Text
            self.validate_Max35Text(self.CtrctId)
# end class ExchangeRateInformation1


class FinancialIdentificationSchemeName1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalFinancialInstitutionIdentification1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinancialIdentificationSchemeName1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinancialIdentificationSchemeName1Choice.subclass:
            return FinancialIdentificationSchemeName1Choice.subclass(*args_, **kwargs_)
        else:
            return FinancialIdentificationSchemeName1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalFinancialInstitutionIdentification1Code(self, value):
        # Validate type ExternalFinancialInstitutionIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalFinancialInstitutionIdentification1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalFinancialInstitutionIdentification1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinancialIdentificationSchemeName1Choice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinancialIdentificationSchemeName1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinancialIdentificationSchemeName1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinancialIdentificationSchemeName1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinancialIdentificationSchemeName1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            self.Prtry.export(outfile, level, namespace_, name_='Prtry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalFinancialInstitutionIdentification1Code
            self.validate_ExternalFinancialInstitutionIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            obj_ = None
            self.Prtry = obj_
            obj_.original_tagname_ = 'Prtry'
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class FinancialIdentificationSchemeName1Choice


class FinancialInstitutionIdentification7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BIC=None, ClrSysMmbId=None, Nm=None, PstlAdr=None, Othr=None):
        self.original_tagname_ = None
        self.BIC = BIC
        self.validate_BICIdentifier(self.BIC)
        self.ClrSysMmbId = ClrSysMmbId
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.PstlAdr = PstlAdr
        self.Othr = Othr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinancialInstitutionIdentification7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinancialInstitutionIdentification7.subclass:
            return FinancialInstitutionIdentification7.subclass(*args_, **kwargs_)
        else:
            return FinancialInstitutionIdentification7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BIC(self): return self.BIC
    def set_BIC(self, BIC): self.BIC = BIC
    def get_ClrSysMmbId(self): return self.ClrSysMmbId
    def set_ClrSysMmbId(self, ClrSysMmbId): self.ClrSysMmbId = ClrSysMmbId
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_PstlAdr(self): return self.PstlAdr
    def set_PstlAdr(self, PstlAdr): self.PstlAdr = PstlAdr
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def validate_BICIdentifier(self, value):
        # Validate type BICIdentifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_BICIdentifier_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_BICIdentifier_patterns_, ))
    validate_BICIdentifier_patterns_ = [['^[A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}$']]
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max140Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max140Text_patterns_, ))
    validate_Max140Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.BIC is not None or
            self.ClrSysMmbId is not None or
            self.Nm is not None or
            self.PstlAdr is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinancialInstitutionIdentification7', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinancialInstitutionIdentification7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinancialInstitutionIdentification7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinancialInstitutionIdentification7'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinancialInstitutionIdentification7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BIC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBIC>%s</%sBIC>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BIC), input_name='BIC')), namespace_, eol_))
        if self.ClrSysMmbId is not None:
            self.ClrSysMmbId.export(outfile, level, namespace_, name_='ClrSysMmbId', pretty_print=pretty_print)
        if self.Nm is not None:
            self.Nm.export(outfile, level, namespace_, name_='Nm', pretty_print=pretty_print)
        if self.PstlAdr is not None:
            self.PstlAdr.export(outfile, level, namespace_, name_='PstlAdr', pretty_print=pretty_print)
        if self.Othr is not None:
            self.Othr.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BIC':
            BIC_ = child_.text
            BIC_ = self.gds_validate_string(BIC_, node, 'BIC')
            self.BIC = BIC_
            # validate type BICIdentifier
            self.validate_BICIdentifier(self.BIC)
        elif nodeName_ == 'ClrSysMmbId':
            obj_ = ClearingSystemMemberIdentification2.factory()
            obj_.build(child_)
            self.ClrSysMmbId = obj_
            obj_.original_tagname_ = 'ClrSysMmbId'
        elif nodeName_ == 'Nm':
            obj_ = None
            self.Nm = obj_
            obj_.original_tagname_ = 'Nm'
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress6.factory()
            obj_.build(child_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
        elif nodeName_ == 'Othr':
            obj_ = GenericFinancialIdentification1.factory()
            obj_.build(child_)
            self.Othr = obj_
            obj_.original_tagname_ = 'Othr'
# end class FinancialInstitutionIdentification7


class FinancialInstitutionIdentification7_CH_BicOrClrId(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BIC=None, ClrSysMmbId=None):
        self.original_tagname_ = None
        self.BIC = BIC
        self.validate_BICIdentifier(self.BIC)
        self.ClrSysMmbId = ClrSysMmbId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinancialInstitutionIdentification7_CH_BicOrClrId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinancialInstitutionIdentification7_CH_BicOrClrId.subclass:
            return FinancialInstitutionIdentification7_CH_BicOrClrId.subclass(*args_, **kwargs_)
        else:
            return FinancialInstitutionIdentification7_CH_BicOrClrId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BIC(self): return self.BIC
    def set_BIC(self, BIC): self.BIC = BIC
    def get_ClrSysMmbId(self): return self.ClrSysMmbId
    def set_ClrSysMmbId(self, ClrSysMmbId): self.ClrSysMmbId = ClrSysMmbId
    def validate_BICIdentifier(self, value):
        # Validate type BICIdentifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_BICIdentifier_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_BICIdentifier_patterns_, ))
    validate_BICIdentifier_patterns_ = [['^[A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}$']]
    def hasContent_(self):
        if (
            self.BIC is not None or
            self.ClrSysMmbId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinancialInstitutionIdentification7-CH_BicOrClrId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinancialInstitutionIdentification7-CH_BicOrClrId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinancialInstitutionIdentification7-CH_BicOrClrId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinancialInstitutionIdentification7-CH_BicOrClrId'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinancialInstitutionIdentification7-CH_BicOrClrId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BIC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBIC>%s</%sBIC>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BIC), input_name='BIC')), namespace_, eol_))
        if self.ClrSysMmbId is not None:
            self.ClrSysMmbId.export(outfile, level, namespace_, name_='ClrSysMmbId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BIC':
            BIC_ = child_.text
            BIC_ = self.gds_validate_string(BIC_, node, 'BIC')
            self.BIC = BIC_
            # validate type BICIdentifier
            self.validate_BICIdentifier(self.BIC)
        elif nodeName_ == 'ClrSysMmbId':
            obj_ = ClearingSystemMemberIdentification2.factory()
            obj_.build(child_)
            self.ClrSysMmbId = obj_
            obj_.original_tagname_ = 'ClrSysMmbId'
# end class FinancialInstitutionIdentification7_CH_BicOrClrId


class FinancialInstitutionIdentification7_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BIC=None, ClrSysMmbId=None, Nm=None, PstlAdr=None, Othr=None):
        self.original_tagname_ = None
        self.BIC = BIC
        self.validate_BICIdentifier(self.BIC)
        self.ClrSysMmbId = ClrSysMmbId
        self.Nm = Nm
        self.validate_Max70Text(self.Nm)
        self.PstlAdr = PstlAdr
        self.Othr = Othr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinancialInstitutionIdentification7_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinancialInstitutionIdentification7_CH.subclass:
            return FinancialInstitutionIdentification7_CH.subclass(*args_, **kwargs_)
        else:
            return FinancialInstitutionIdentification7_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BIC(self): return self.BIC
    def set_BIC(self, BIC): self.BIC = BIC
    def get_ClrSysMmbId(self): return self.ClrSysMmbId
    def set_ClrSysMmbId(self, ClrSysMmbId): self.ClrSysMmbId = ClrSysMmbId
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_PstlAdr(self): return self.PstlAdr
    def set_PstlAdr(self, PstlAdr): self.PstlAdr = PstlAdr
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def validate_BICIdentifier(self, value):
        # Validate type BICIdentifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_BICIdentifier_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_BICIdentifier_patterns_, ))
    validate_BICIdentifier_patterns_ = [['^[A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}$']]
    def validate_Max70Text(self, value):
        # Validate type Max70Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max70Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max70Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max70Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max70Text_patterns_, ))
    validate_Max70Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.BIC is not None or
            self.ClrSysMmbId is not None or
            self.Nm is not None or
            self.PstlAdr is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinancialInstitutionIdentification7-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinancialInstitutionIdentification7-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinancialInstitutionIdentification7-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinancialInstitutionIdentification7-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinancialInstitutionIdentification7-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BIC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBIC>%s</%sBIC>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BIC), input_name='BIC')), namespace_, eol_))
        if self.ClrSysMmbId is not None:
            self.ClrSysMmbId.export(outfile, level, namespace_, name_='ClrSysMmbId', pretty_print=pretty_print)
        if self.Nm is not None:
            self.Nm.export(outfile, level, namespace_, name_='Nm', pretty_print=pretty_print)
        if self.PstlAdr is not None:
            self.PstlAdr.export(outfile, level, namespace_, name_='PstlAdr', pretty_print=pretty_print)
        if self.Othr is not None:
            self.Othr.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BIC':
            BIC_ = child_.text
            BIC_ = self.gds_validate_string(BIC_, node, 'BIC')
            self.BIC = BIC_
            # validate type BICIdentifier
            self.validate_BICIdentifier(self.BIC)
        elif nodeName_ == 'ClrSysMmbId':
            obj_ = ClearingSystemMemberIdentification2.factory()
            obj_.build(child_)
            self.ClrSysMmbId = obj_
            obj_.original_tagname_ = 'ClrSysMmbId'
        elif nodeName_ == 'Nm':
            obj_ = None
            self.Nm = obj_
            obj_.original_tagname_ = 'Nm'
            # validate type Max70Text
            self.validate_Max70Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress6_CH.factory()
            obj_.build(child_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
        elif nodeName_ == 'Othr':
            obj_ = GenericFinancialIdentification1_CH.factory()
            obj_.build(child_)
            self.Othr = obj_
            obj_.original_tagname_ = 'Othr'
# end class FinancialInstitutionIdentification7_CH


class GenericAccountIdentification1_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None):
        self.original_tagname_ = None
        self.Id = Id
        self.validate_Max34Text(self.Id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericAccountIdentification1_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericAccountIdentification1_CH.subclass:
            return GenericAccountIdentification1_CH.subclass(*args_, **kwargs_)
        else:
            return GenericAccountIdentification1_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def validate_Max34Text(self, value):
        # Validate type Max34Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 34:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max34Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max34Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max34Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max34Text_patterns_, ))
    validate_Max34Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericAccountIdentification1-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericAccountIdentification1-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericAccountIdentification1-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericAccountIdentification1-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericAccountIdentification1-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            obj_ = None
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
            # validate type Max34Text
            self.validate_Max34Text(self.Id)
# end class GenericAccountIdentification1_CH


class GenericFinancialIdentification1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SchmeNm=None, Issr=None):
        self.original_tagname_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.SchmeNm = SchmeNm
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericFinancialIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericFinancialIdentification1.subclass:
            return GenericFinancialIdentification1.subclass(*args_, **kwargs_)
        else:
            return GenericFinancialIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_SchmeNm(self): return self.SchmeNm
    def set_SchmeNm(self, SchmeNm): self.SchmeNm = SchmeNm
    def get_Issr(self): return self.Issr
    def set_Issr(self, Issr): self.Issr = Issr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Id is not None or
            self.SchmeNm is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericFinancialIdentification1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericFinancialIdentification1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericFinancialIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericFinancialIdentification1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericFinancialIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
        if self.SchmeNm is not None:
            self.SchmeNm.export(outfile, level, namespace_, name_='SchmeNm', pretty_print=pretty_print)
        if self.Issr is not None:
            self.Issr.export(outfile, level, namespace_, name_='Issr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            obj_ = None
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'SchmeNm':
            obj_ = FinancialIdentificationSchemeName1Choice.factory()
            obj_.build(child_)
            self.SchmeNm = obj_
            obj_.original_tagname_ = 'SchmeNm'
        elif nodeName_ == 'Issr':
            obj_ = None
            self.Issr = obj_
            obj_.original_tagname_ = 'Issr'
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GenericFinancialIdentification1


class GenericFinancialIdentification1_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None):
        self.original_tagname_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericFinancialIdentification1_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericFinancialIdentification1_CH.subclass:
            return GenericFinancialIdentification1_CH.subclass(*args_, **kwargs_)
        else:
            return GenericFinancialIdentification1_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericFinancialIdentification1-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericFinancialIdentification1-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericFinancialIdentification1-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericFinancialIdentification1-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericFinancialIdentification1-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            obj_ = None
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
# end class GenericFinancialIdentification1_CH


class GenericOrganisationIdentification1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SchmeNm=None, Issr=None):
        self.original_tagname_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.SchmeNm = SchmeNm
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericOrganisationIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericOrganisationIdentification1.subclass:
            return GenericOrganisationIdentification1.subclass(*args_, **kwargs_)
        else:
            return GenericOrganisationIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_SchmeNm(self): return self.SchmeNm
    def set_SchmeNm(self, SchmeNm): self.SchmeNm = SchmeNm
    def get_Issr(self): return self.Issr
    def set_Issr(self, Issr): self.Issr = Issr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Id is not None or
            self.SchmeNm is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericOrganisationIdentification1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericOrganisationIdentification1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericOrganisationIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericOrganisationIdentification1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericOrganisationIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
        if self.SchmeNm is not None:
            self.SchmeNm.export(outfile, level, namespace_, name_='SchmeNm', pretty_print=pretty_print)
        if self.Issr is not None:
            self.Issr.export(outfile, level, namespace_, name_='Issr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            obj_ = None
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'SchmeNm':
            obj_ = OrganisationIdentificationSchemeName1Choice.factory()
            obj_.build(child_)
            self.SchmeNm = obj_
            obj_.original_tagname_ = 'SchmeNm'
        elif nodeName_ == 'Issr':
            obj_ = None
            self.Issr = obj_
            obj_.original_tagname_ = 'Issr'
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GenericOrganisationIdentification1


class GenericPersonIdentification1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SchmeNm=None, Issr=None):
        self.original_tagname_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.SchmeNm = SchmeNm
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericPersonIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericPersonIdentification1.subclass:
            return GenericPersonIdentification1.subclass(*args_, **kwargs_)
        else:
            return GenericPersonIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_SchmeNm(self): return self.SchmeNm
    def set_SchmeNm(self, SchmeNm): self.SchmeNm = SchmeNm
    def get_Issr(self): return self.Issr
    def set_Issr(self, Issr): self.Issr = Issr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Id is not None or
            self.SchmeNm is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericPersonIdentification1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericPersonIdentification1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericPersonIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericPersonIdentification1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericPersonIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
        if self.SchmeNm is not None:
            self.SchmeNm.export(outfile, level, namespace_, name_='SchmeNm', pretty_print=pretty_print)
        if self.Issr is not None:
            self.Issr.export(outfile, level, namespace_, name_='Issr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            obj_ = None
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'SchmeNm':
            obj_ = PersonIdentificationSchemeName1Choice.factory()
            obj_.build(child_)
            self.SchmeNm = obj_
            obj_.original_tagname_ = 'SchmeNm'
        elif nodeName_ == 'Issr':
            obj_ = None
            self.Issr = obj_
            obj_.original_tagname_ = 'Issr'
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GenericPersonIdentification1


class GroupHeader32_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MsgId=None, CreDtTm=None, NbOfTxs=None, CtrlSum=None, InitgPty=None, FwdgAgt=None):
        self.original_tagname_ = None
        self.MsgId = MsgId
        if isinstance(CreDtTm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CreDtTm, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CreDtTm
        self.CreDtTm = initvalue_
        self.NbOfTxs = NbOfTxs
        self.validate_Max15NumericText(self.NbOfTxs)
        self.CtrlSum = CtrlSum
        self.validate_DecimalNumber(self.CtrlSum)
        self.InitgPty = InitgPty
        self.FwdgAgt = FwdgAgt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GroupHeader32_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GroupHeader32_CH.subclass:
            return GroupHeader32_CH.subclass(*args_, **kwargs_)
        else:
            return GroupHeader32_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MsgId(self): return self.MsgId
    def set_MsgId(self, MsgId): self.MsgId = MsgId
    def get_CreDtTm(self): return self.CreDtTm
    def set_CreDtTm(self, CreDtTm): self.CreDtTm = CreDtTm
    def get_NbOfTxs(self): return self.NbOfTxs
    def set_NbOfTxs(self, NbOfTxs): self.NbOfTxs = NbOfTxs
    def get_CtrlSum(self): return self.CtrlSum
    def set_CtrlSum(self, CtrlSum): self.CtrlSum = CtrlSum
    def get_InitgPty(self): return self.InitgPty
    def set_InitgPty(self, InitgPty): self.InitgPty = InitgPty
    def get_FwdgAgt(self): return self.FwdgAgt
    def set_FwdgAgt(self, FwdgAgt): self.FwdgAgt = FwdgAgt
    def validate_ISODateTime(self, value):
        # Validate type ISODateTime, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_Max15NumericText(self, value):
        # Validate type Max15NumericText, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_Max15NumericText_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max15NumericText_patterns_, ))
    validate_Max15NumericText_patterns_ = [['^[0-9]{1,15}$']]
    def validate_DecimalNumber(self, value):
        # Validate type DecimalNumber, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DecimalNumber' % {"value" : value} )
    def hasContent_(self):
        if (
            self.MsgId is not None or
            self.CreDtTm is not None or
            self.NbOfTxs is not None or
            self.CtrlSum is not None or
            self.InitgPty is not None or
            self.FwdgAgt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GroupHeader32-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupHeader32-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GroupHeader32-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupHeader32-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GroupHeader32-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MsgId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMsgId>%s</%sMsgId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MsgId), input_name='MsgId')), namespace_, eol_))
        if self.CreDtTm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreDtTm>%s</%sCreDtTm>%s' % (namespace_, self.gds_format_datetime(self.CreDtTm, input_name='CreDtTm'), namespace_, eol_))
        if self.NbOfTxs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNbOfTxs>%s</%sNbOfTxs>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NbOfTxs), input_name='NbOfTxs')), namespace_, eol_))
        if self.CtrlSum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtrlSum>%s</%sCtrlSum>%s' % (namespace_, self.gds_format_float(self.CtrlSum, input_name='CtrlSum'), namespace_, eol_))
        if self.InitgPty is not None:
            self.InitgPty.export(outfile, level, namespace_, name_='InitgPty', pretty_print=pretty_print)
        if self.FwdgAgt is not None:
            self.FwdgAgt.export(outfile, level, namespace_, name_='FwdgAgt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MsgId':
            MsgId_ = child_.text
            MsgId_ = self.gds_validate_string(MsgId_, node, 'MsgId')
            self.MsgId = MsgId_
        elif nodeName_ == 'CreDtTm':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.CreDtTm = dval_
            # validate type ISODateTime
            self.validate_ISODateTime(self.CreDtTm)
        elif nodeName_ == 'NbOfTxs':
            NbOfTxs_ = child_.text
            NbOfTxs_ = self.gds_validate_string(NbOfTxs_, node, 'NbOfTxs')
            self.NbOfTxs = NbOfTxs_
            # validate type Max15NumericText
            self.validate_Max15NumericText(self.NbOfTxs)
        elif nodeName_ == 'CtrlSum':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CtrlSum')
            self.CtrlSum = fval_
            # validate type DecimalNumber
            self.validate_DecimalNumber(self.CtrlSum)
        elif nodeName_ == 'InitgPty':
            obj_ = PartyIdentification32_CH_NameAndId.factory()
            obj_.build(child_)
            self.InitgPty = obj_
            obj_.original_tagname_ = 'InitgPty'
        elif nodeName_ == 'FwdgAgt':
            obj_ = BranchAndFinancialInstitutionIdentification4.factory()
            obj_.build(child_)
            self.FwdgAgt = obj_
            obj_.original_tagname_ = 'FwdgAgt'
# end class GroupHeader32_CH


class InstructionForCreditorAgent1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, InstrInf=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_Instruction3Code(self.Cd)
        self.InstrInf = InstrInf
        self.validate_Max140Text(self.InstrInf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstructionForCreditorAgent1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstructionForCreditorAgent1.subclass:
            return InstructionForCreditorAgent1.subclass(*args_, **kwargs_)
        else:
            return InstructionForCreditorAgent1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_InstrInf(self): return self.InstrInf
    def set_InstrInf(self, InstrInf): self.InstrInf = InstrInf
    def validate_Instruction3Code(self, value):
        # Validate type Instruction3Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CHQB', 'HOLD', 'PHOB', 'TELB']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Instruction3Code' % {"value" : value.encode("utf-8")} )
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max140Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max140Text_patterns_, ))
    validate_Max140Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.InstrInf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstructionForCreditorAgent1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstructionForCreditorAgent1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstructionForCreditorAgent1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstructionForCreditorAgent1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InstructionForCreditorAgent1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.InstrInf is not None:
            self.InstrInf.export(outfile, level, namespace_, name_='InstrInf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type Instruction3Code
            self.validate_Instruction3Code(self.Cd)
        elif nodeName_ == 'InstrInf':
            obj_ = None
            self.InstrInf = obj_
            obj_.original_tagname_ = 'InstrInf'
            # validate type Max140Text
            self.validate_Max140Text(self.InstrInf)
# end class InstructionForCreditorAgent1


class LocalInstrument2Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalLocalInstrument1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocalInstrument2Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalInstrument2Choice.subclass:
            return LocalInstrument2Choice.subclass(*args_, **kwargs_)
        else:
            return LocalInstrument2Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalLocalInstrument1Code(self, value):
        # Validate type ExternalLocalInstrument1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalLocalInstrument1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalLocalInstrument1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LocalInstrument2Choice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalInstrument2Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LocalInstrument2Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalInstrument2Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocalInstrument2Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            self.Prtry.export(outfile, level, namespace_, name_='Prtry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalLocalInstrument1Code
            self.validate_ExternalLocalInstrument1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            obj_ = None
            self.Prtry = obj_
            obj_.original_tagname_ = 'Prtry'
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class LocalInstrument2Choice


class OrganisationIdentification4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BICOrBEI=None, Othr=None):
        self.original_tagname_ = None
        self.BICOrBEI = BICOrBEI
        self.validate_AnyBICIdentifier(self.BICOrBEI)
        if Othr is None:
            self.Othr = []
        else:
            self.Othr = Othr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganisationIdentification4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganisationIdentification4.subclass:
            return OrganisationIdentification4.subclass(*args_, **kwargs_)
        else:
            return OrganisationIdentification4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BICOrBEI(self): return self.BICOrBEI
    def set_BICOrBEI(self, BICOrBEI): self.BICOrBEI = BICOrBEI
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def add_Othr(self, value): self.Othr.append(value)
    def insert_Othr_at(self, index, value): self.Othr.insert(index, value)
    def replace_Othr_at(self, index, value): self.Othr[index] = value
    def validate_AnyBICIdentifier(self, value):
        # Validate type AnyBICIdentifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AnyBICIdentifier_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AnyBICIdentifier_patterns_, ))
    validate_AnyBICIdentifier_patterns_ = [['^[A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}$']]
    def hasContent_(self):
        if (
            self.BICOrBEI is not None or
            self.Othr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrganisationIdentification4', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationIdentification4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrganisationIdentification4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganisationIdentification4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OrganisationIdentification4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BICOrBEI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBICOrBEI>%s</%sBICOrBEI>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BICOrBEI), input_name='BICOrBEI')), namespace_, eol_))
        for Othr_ in self.Othr:
            Othr_.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BICOrBEI':
            BICOrBEI_ = child_.text
            BICOrBEI_ = self.gds_validate_string(BICOrBEI_, node, 'BICOrBEI')
            self.BICOrBEI = BICOrBEI_
            # validate type AnyBICIdentifier
            self.validate_AnyBICIdentifier(self.BICOrBEI)
        elif nodeName_ == 'Othr':
            obj_ = GenericOrganisationIdentification1.factory()
            obj_.build(child_)
            self.Othr.append(obj_)
            obj_.original_tagname_ = 'Othr'
# end class OrganisationIdentification4


class OrganisationIdentification4_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BICOrBEI=None, Othr=None):
        self.original_tagname_ = None
        self.BICOrBEI = BICOrBEI
        self.validate_AnyBICIdentifier(self.BICOrBEI)
        self.Othr = Othr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganisationIdentification4_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganisationIdentification4_CH.subclass:
            return OrganisationIdentification4_CH.subclass(*args_, **kwargs_)
        else:
            return OrganisationIdentification4_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BICOrBEI(self): return self.BICOrBEI
    def set_BICOrBEI(self, BICOrBEI): self.BICOrBEI = BICOrBEI
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def validate_AnyBICIdentifier(self, value):
        # Validate type AnyBICIdentifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AnyBICIdentifier_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AnyBICIdentifier_patterns_, ))
    validate_AnyBICIdentifier_patterns_ = [['^[A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}$']]
    def hasContent_(self):
        if (
            self.BICOrBEI is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrganisationIdentification4-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationIdentification4-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrganisationIdentification4-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganisationIdentification4-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OrganisationIdentification4-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BICOrBEI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBICOrBEI>%s</%sBICOrBEI>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BICOrBEI), input_name='BICOrBEI')), namespace_, eol_))
        if self.Othr is not None:
            self.Othr.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BICOrBEI':
            BICOrBEI_ = child_.text
            BICOrBEI_ = self.gds_validate_string(BICOrBEI_, node, 'BICOrBEI')
            self.BICOrBEI = BICOrBEI_
            # validate type AnyBICIdentifier
            self.validate_AnyBICIdentifier(self.BICOrBEI)
        elif nodeName_ == 'Othr':
            obj_ = GenericOrganisationIdentification1.factory()
            obj_.build(child_)
            self.Othr = obj_
            obj_.original_tagname_ = 'Othr'
# end class OrganisationIdentification4_CH


class OrganisationIdentificationSchemeName1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalOrganisationIdentification1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganisationIdentificationSchemeName1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganisationIdentificationSchemeName1Choice.subclass:
            return OrganisationIdentificationSchemeName1Choice.subclass(*args_, **kwargs_)
        else:
            return OrganisationIdentificationSchemeName1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalOrganisationIdentification1Code(self, value):
        # Validate type ExternalOrganisationIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalOrganisationIdentification1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalOrganisationIdentification1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrganisationIdentificationSchemeName1Choice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationIdentificationSchemeName1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrganisationIdentificationSchemeName1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganisationIdentificationSchemeName1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OrganisationIdentificationSchemeName1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            self.Prtry.export(outfile, level, namespace_, name_='Prtry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalOrganisationIdentification1Code
            self.validate_ExternalOrganisationIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            obj_ = None
            self.Prtry = obj_
            obj_.original_tagname_ = 'Prtry'
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class OrganisationIdentificationSchemeName1Choice


class Party6Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OrgId=None, PrvtId=None):
        self.original_tagname_ = None
        self.OrgId = OrgId
        self.PrvtId = PrvtId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Party6Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Party6Choice.subclass:
            return Party6Choice.subclass(*args_, **kwargs_)
        else:
            return Party6Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OrgId(self): return self.OrgId
    def set_OrgId(self, OrgId): self.OrgId = OrgId
    def get_PrvtId(self): return self.PrvtId
    def set_PrvtId(self, PrvtId): self.PrvtId = PrvtId
    def hasContent_(self):
        if (
            self.OrgId is not None or
            self.PrvtId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Party6Choice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Party6Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Party6Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Party6Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Party6Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrgId is not None:
            self.OrgId.export(outfile, level, namespace_, name_='OrgId', pretty_print=pretty_print)
        if self.PrvtId is not None:
            self.PrvtId.export(outfile, level, namespace_, name_='PrvtId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OrgId':
            obj_ = OrganisationIdentification4.factory()
            obj_.build(child_)
            self.OrgId = obj_
            obj_.original_tagname_ = 'OrgId'
        elif nodeName_ == 'PrvtId':
            obj_ = PersonIdentification5.factory()
            obj_.build(child_)
            self.PrvtId = obj_
            obj_.original_tagname_ = 'PrvtId'
# end class Party6Choice


class Party6Choice_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OrgId=None, PrvtId=None):
        self.original_tagname_ = None
        self.OrgId = OrgId
        self.PrvtId = PrvtId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Party6Choice_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Party6Choice_CH.subclass:
            return Party6Choice_CH.subclass(*args_, **kwargs_)
        else:
            return Party6Choice_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OrgId(self): return self.OrgId
    def set_OrgId(self, OrgId): self.OrgId = OrgId
    def get_PrvtId(self): return self.PrvtId
    def set_PrvtId(self, PrvtId): self.PrvtId = PrvtId
    def hasContent_(self):
        if (
            self.OrgId is not None or
            self.PrvtId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Party6Choice-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Party6Choice-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Party6Choice-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Party6Choice-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Party6Choice-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrgId is not None:
            self.OrgId.export(outfile, level, namespace_, name_='OrgId', pretty_print=pretty_print)
        if self.PrvtId is not None:
            self.PrvtId.export(outfile, level, namespace_, name_='PrvtId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OrgId':
            obj_ = OrganisationIdentification4_CH.factory()
            obj_.build(child_)
            self.OrgId = obj_
            obj_.original_tagname_ = 'OrgId'
        elif nodeName_ == 'PrvtId':
            obj_ = PersonIdentification5_CH.factory()
            obj_.build(child_)
            self.PrvtId = obj_
            obj_.original_tagname_ = 'PrvtId'
# end class Party6Choice_CH


class PartyIdentification32(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Nm=None, PstlAdr=None, Id=None, CtryOfRes=None, CtctDtls=None):
        self.original_tagname_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.PstlAdr = PstlAdr
        self.Id = Id
        self.CtryOfRes = CtryOfRes
        self.validate_CountryCode(self.CtryOfRes)
        self.CtctDtls = CtctDtls
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyIdentification32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyIdentification32.subclass:
            return PartyIdentification32.subclass(*args_, **kwargs_)
        else:
            return PartyIdentification32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_PstlAdr(self): return self.PstlAdr
    def set_PstlAdr(self, PstlAdr): self.PstlAdr = PstlAdr
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_CtryOfRes(self): return self.CtryOfRes
    def set_CtryOfRes(self, CtryOfRes): self.CtryOfRes = CtryOfRes
    def get_CtctDtls(self): return self.CtctDtls
    def set_CtctDtls(self, CtctDtls): self.CtctDtls = CtctDtls
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max140Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max140Text_patterns_, ))
    validate_Max140Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CountryCode_patterns_, ))
    validate_CountryCode_patterns_ = [['^[A-Z]{2,2}$']]
    def hasContent_(self):
        if (
            self.Nm is not None or
            self.PstlAdr is not None or
            self.Id is not None or
            self.CtryOfRes is not None or
            self.CtctDtls is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyIdentification32', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyIdentification32')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyIdentification32', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyIdentification32'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyIdentification32', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            self.Nm.export(outfile, level, namespace_, name_='Nm', pretty_print=pretty_print)
        if self.PstlAdr is not None:
            self.PstlAdr.export(outfile, level, namespace_, name_='PstlAdr', pretty_print=pretty_print)
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
        if self.CtryOfRes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtryOfRes>%s</%sCtryOfRes>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CtryOfRes), input_name='CtryOfRes')), namespace_, eol_))
        if self.CtctDtls is not None:
            self.CtctDtls.export(outfile, level, namespace_, name_='CtctDtls', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nm':
            obj_ = None
            self.Nm = obj_
            obj_.original_tagname_ = 'Nm'
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress6.factory()
            obj_.build(child_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
        elif nodeName_ == 'Id':
            obj_ = Party6Choice.factory()
            obj_.build(child_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'CtryOfRes':
            CtryOfRes_ = child_.text
            CtryOfRes_ = self.gds_validate_string(CtryOfRes_, node, 'CtryOfRes')
            self.CtryOfRes = CtryOfRes_
            # validate type CountryCode
            self.validate_CountryCode(self.CtryOfRes)
        elif nodeName_ == 'CtctDtls':
            obj_ = ContactDetails2.factory()
            obj_.build(child_)
            self.CtctDtls = obj_
            obj_.original_tagname_ = 'CtctDtls'
# end class PartyIdentification32


class PartyIdentification32_CH_NameAndId(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Nm=None, Id=None, CtctDtls=None):
        self.original_tagname_ = None
        self.Nm = Nm
        self.validate_Max70Text(self.Nm)
        self.Id = Id
        self.CtctDtls = CtctDtls
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyIdentification32_CH_NameAndId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyIdentification32_CH_NameAndId.subclass:
            return PartyIdentification32_CH_NameAndId.subclass(*args_, **kwargs_)
        else:
            return PartyIdentification32_CH_NameAndId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_CtctDtls(self): return self.CtctDtls
    def set_CtctDtls(self, CtctDtls): self.CtctDtls = CtctDtls
    def validate_Max70Text(self, value):
        # Validate type Max70Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max70Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max70Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max70Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max70Text_patterns_, ))
    validate_Max70Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Nm is not None or
            self.Id is not None or
            self.CtctDtls is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyIdentification32-CH_NameAndId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyIdentification32-CH_NameAndId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyIdentification32-CH_NameAndId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyIdentification32-CH_NameAndId'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyIdentification32-CH_NameAndId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            self.Nm.export(outfile, level, namespace_, name_='Nm', pretty_print=pretty_print)
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
        if self.CtctDtls is not None:
            self.CtctDtls.export(outfile, level, namespace_, name_='CtctDtls', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nm':
            obj_ = None
            self.Nm = obj_
            obj_.original_tagname_ = 'Nm'
            # validate type Max70Text
            self.validate_Max70Text(self.Nm)
        elif nodeName_ == 'Id':
            obj_ = Party6Choice_CH.factory()
            obj_.build(child_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'CtctDtls':
            obj_ = ContactDetails2_CH.factory()
            obj_.build(child_)
            self.CtctDtls = obj_
            obj_.original_tagname_ = 'CtctDtls'
# end class PartyIdentification32_CH_NameAndId


class PartyIdentification32_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Nm=None, PstlAdr=None, Id=None):
        self.original_tagname_ = None
        self.Nm = Nm
        self.validate_Max70Text(self.Nm)
        self.PstlAdr = PstlAdr
        self.Id = Id
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyIdentification32_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyIdentification32_CH.subclass:
            return PartyIdentification32_CH.subclass(*args_, **kwargs_)
        else:
            return PartyIdentification32_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_PstlAdr(self): return self.PstlAdr
    def set_PstlAdr(self, PstlAdr): self.PstlAdr = PstlAdr
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def validate_Max70Text(self, value):
        # Validate type Max70Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max70Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max70Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max70Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max70Text_patterns_, ))
    validate_Max70Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Nm is not None or
            self.PstlAdr is not None or
            self.Id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyIdentification32-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyIdentification32-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyIdentification32-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyIdentification32-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyIdentification32-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            self.Nm.export(outfile, level, namespace_, name_='Nm', pretty_print=pretty_print)
        if self.PstlAdr is not None:
            self.PstlAdr.export(outfile, level, namespace_, name_='PstlAdr', pretty_print=pretty_print)
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nm':
            obj_ = None
            self.Nm = obj_
            obj_.original_tagname_ = 'Nm'
            # validate type Max70Text
            self.validate_Max70Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress6_CH.factory()
            obj_.build(child_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
        elif nodeName_ == 'Id':
            obj_ = Party6Choice_CH.factory()
            obj_.build(child_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
# end class PartyIdentification32_CH


class PartyIdentification32_CH_Name(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Nm=None, PstlAdr=None, Id=None):
        self.original_tagname_ = None
        self.Nm = Nm
        self.validate_Max70Text(self.Nm)
        self.PstlAdr = PstlAdr
        self.Id = Id
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyIdentification32_CH_Name)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyIdentification32_CH_Name.subclass:
            return PartyIdentification32_CH_Name.subclass(*args_, **kwargs_)
        else:
            return PartyIdentification32_CH_Name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_PstlAdr(self): return self.PstlAdr
    def set_PstlAdr(self, PstlAdr): self.PstlAdr = PstlAdr
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def validate_Max70Text(self, value):
        # Validate type Max70Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max70Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max70Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max70Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max70Text_patterns_, ))
    validate_Max70Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Nm is not None or
            self.PstlAdr is not None or
            self.Id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyIdentification32-CH_Name', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyIdentification32-CH_Name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyIdentification32-CH_Name', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyIdentification32-CH_Name'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyIdentification32-CH_Name', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            self.Nm.export(outfile, level, namespace_, name_='Nm', pretty_print=pretty_print)
        if self.PstlAdr is not None:
            self.PstlAdr.export(outfile, level, namespace_, name_='PstlAdr', pretty_print=pretty_print)
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nm':
            obj_ = None
            self.Nm = obj_
            obj_.original_tagname_ = 'Nm'
            # validate type Max70Text
            self.validate_Max70Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress6_CH.factory()
            obj_.build(child_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
        elif nodeName_ == 'Id':
            obj_ = Party6Choice_CH.factory()
            obj_.build(child_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
# end class PartyIdentification32_CH_Name


class PaymentIdentification1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InstrId=None, EndToEndId=None):
        self.original_tagname_ = None
        self.InstrId = InstrId
        self.EndToEndId = EndToEndId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentIdentification1.subclass:
            return PaymentIdentification1.subclass(*args_, **kwargs_)
        else:
            return PaymentIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InstrId(self): return self.InstrId
    def set_InstrId(self, InstrId): self.InstrId = InstrId
    def get_EndToEndId(self): return self.EndToEndId
    def set_EndToEndId(self, EndToEndId): self.EndToEndId = EndToEndId
    def hasContent_(self):
        if (
            self.InstrId is not None or
            self.EndToEndId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentIdentification1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentIdentification1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentIdentification1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InstrId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrId>%s</%sInstrId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InstrId), input_name='InstrId')), namespace_, eol_))
        if self.EndToEndId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndToEndId>%s</%sEndToEndId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EndToEndId), input_name='EndToEndId')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InstrId':
            InstrId_ = child_.text
            InstrId_ = self.gds_validate_string(InstrId_, node, 'InstrId')
            self.InstrId = InstrId_
        elif nodeName_ == 'EndToEndId':
            EndToEndId_ = child_.text
            EndToEndId_ = self.gds_validate_string(EndToEndId_, node, 'EndToEndId')
            self.EndToEndId = EndToEndId_
# end class PaymentIdentification1


class PaymentInstructionInformation3_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PmtInfId=None, PmtMtd=None, BtchBookg=None, NbOfTxs=None, CtrlSum=None, PmtTpInf=None, ReqdExctnDt=None, Dbtr=None, DbtrAcct=None, DbtrAgt=None, UltmtDbtr=None, ChrgBr=None, ChrgsAcct=None, CdtTrfTxInf=None):
        self.original_tagname_ = None
        self.PmtInfId = PmtInfId
        self.PmtMtd = PmtMtd
        self.validate_PaymentMethod3Code(self.PmtMtd)
        self.BtchBookg = BtchBookg
        self.validate_BatchBookingIndicator(self.BtchBookg)
        self.NbOfTxs = NbOfTxs
        self.validate_Max15NumericText(self.NbOfTxs)
        self.CtrlSum = CtrlSum
        self.validate_DecimalNumber(self.CtrlSum)
        self.PmtTpInf = PmtTpInf
        if isinstance(ReqdExctnDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ReqdExctnDt, '%Y-%m-%d').date()
        else:
            initvalue_ = ReqdExctnDt
        self.ReqdExctnDt = initvalue_
        self.Dbtr = Dbtr
        self.DbtrAcct = DbtrAcct
        self.DbtrAgt = DbtrAgt
        self.UltmtDbtr = UltmtDbtr
        self.ChrgBr = ChrgBr
        self.validate_ChargeBearerType1Code(self.ChrgBr)
        self.ChrgsAcct = ChrgsAcct
        if CdtTrfTxInf is None:
            self.CdtTrfTxInf = []
        else:
            self.CdtTrfTxInf = CdtTrfTxInf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentInstructionInformation3_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentInstructionInformation3_CH.subclass:
            return PaymentInstructionInformation3_CH.subclass(*args_, **kwargs_)
        else:
            return PaymentInstructionInformation3_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PmtInfId(self): return self.PmtInfId
    def set_PmtInfId(self, PmtInfId): self.PmtInfId = PmtInfId
    def get_PmtMtd(self): return self.PmtMtd
    def set_PmtMtd(self, PmtMtd): self.PmtMtd = PmtMtd
    def get_BtchBookg(self): return self.BtchBookg
    def set_BtchBookg(self, BtchBookg): self.BtchBookg = BtchBookg
    def get_NbOfTxs(self): return self.NbOfTxs
    def set_NbOfTxs(self, NbOfTxs): self.NbOfTxs = NbOfTxs
    def get_CtrlSum(self): return self.CtrlSum
    def set_CtrlSum(self, CtrlSum): self.CtrlSum = CtrlSum
    def get_PmtTpInf(self): return self.PmtTpInf
    def set_PmtTpInf(self, PmtTpInf): self.PmtTpInf = PmtTpInf
    def get_ReqdExctnDt(self): return self.ReqdExctnDt
    def set_ReqdExctnDt(self, ReqdExctnDt): self.ReqdExctnDt = ReqdExctnDt
    def get_Dbtr(self): return self.Dbtr
    def set_Dbtr(self, Dbtr): self.Dbtr = Dbtr
    def get_DbtrAcct(self): return self.DbtrAcct
    def set_DbtrAcct(self, DbtrAcct): self.DbtrAcct = DbtrAcct
    def get_DbtrAgt(self): return self.DbtrAgt
    def set_DbtrAgt(self, DbtrAgt): self.DbtrAgt = DbtrAgt
    def get_UltmtDbtr(self): return self.UltmtDbtr
    def set_UltmtDbtr(self, UltmtDbtr): self.UltmtDbtr = UltmtDbtr
    def get_ChrgBr(self): return self.ChrgBr
    def set_ChrgBr(self, ChrgBr): self.ChrgBr = ChrgBr
    def get_ChrgsAcct(self): return self.ChrgsAcct
    def set_ChrgsAcct(self, ChrgsAcct): self.ChrgsAcct = ChrgsAcct
    def get_CdtTrfTxInf(self): return self.CdtTrfTxInf
    def set_CdtTrfTxInf(self, CdtTrfTxInf): self.CdtTrfTxInf = CdtTrfTxInf
    def add_CdtTrfTxInf(self, value): self.CdtTrfTxInf.append(value)
    def insert_CdtTrfTxInf_at(self, index, value): self.CdtTrfTxInf.insert(index, value)
    def replace_CdtTrfTxInf_at(self, index, value): self.CdtTrfTxInf[index] = value
    def validate_PaymentMethod3Code(self, value):
        # Validate type PaymentMethod3Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CHK', 'TRF', 'TRA']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PaymentMethod3Code' % {"value" : value.encode("utf-8")} )
    def validate_BatchBookingIndicator(self, value):
        # Validate type BatchBookingIndicator, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_Max15NumericText(self, value):
        # Validate type Max15NumericText, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_Max15NumericText_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max15NumericText_patterns_, ))
    validate_Max15NumericText_patterns_ = [['^[0-9]{1,15}$']]
    def validate_DecimalNumber(self, value):
        # Validate type DecimalNumber, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DecimalNumber' % {"value" : value} )
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ChargeBearerType1Code(self, value):
        # Validate type ChargeBearerType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEBT', 'CRED', 'SHAR', 'SLEV']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChargeBearerType1Code' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PmtInfId is not None or
            self.PmtMtd is not None or
            self.BtchBookg is not None or
            self.NbOfTxs is not None or
            self.CtrlSum is not None or
            self.PmtTpInf is not None or
            self.ReqdExctnDt is not None or
            self.Dbtr is not None or
            self.DbtrAcct is not None or
            self.DbtrAgt is not None or
            self.UltmtDbtr is not None or
            self.ChrgBr is not None or
            self.ChrgsAcct is not None or
            self.CdtTrfTxInf
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentInstructionInformation3-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentInstructionInformation3-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentInstructionInformation3-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentInstructionInformation3-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentInstructionInformation3-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PmtInfId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPmtInfId>%s</%sPmtInfId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PmtInfId), input_name='PmtInfId')), namespace_, eol_))
        if self.PmtMtd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPmtMtd>%s</%sPmtMtd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PmtMtd), input_name='PmtMtd')), namespace_, eol_))
        if self.BtchBookg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBtchBookg>%s</%sBtchBookg>%s' % (namespace_, self.gds_format_boolean(self.BtchBookg, input_name='BtchBookg'), namespace_, eol_))
        if self.NbOfTxs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNbOfTxs>%s</%sNbOfTxs>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NbOfTxs), input_name='NbOfTxs')), namespace_, eol_))
        if self.CtrlSum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtrlSum>%s</%sCtrlSum>%s' % (namespace_, self.gds_format_float(self.CtrlSum, input_name='CtrlSum'), namespace_, eol_))
        if self.PmtTpInf is not None:
            self.PmtTpInf.export(outfile, level, namespace_, name_='PmtTpInf', pretty_print=pretty_print)
        if self.ReqdExctnDt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReqdExctnDt>%s</%sReqdExctnDt>%s' % (namespace_, self.gds_format_date(self.ReqdExctnDt, input_name='ReqdExctnDt'), namespace_, eol_))
        if self.Dbtr is not None:
            self.Dbtr.export(outfile, level, namespace_, name_='Dbtr', pretty_print=pretty_print)
        if self.DbtrAcct is not None:
            self.DbtrAcct.export(outfile, level, namespace_, name_='DbtrAcct', pretty_print=pretty_print)
        if self.DbtrAgt is not None:
            self.DbtrAgt.export(outfile, level, namespace_, name_='DbtrAgt', pretty_print=pretty_print)
        if self.UltmtDbtr is not None:
            self.UltmtDbtr.export(outfile, level, namespace_, name_='UltmtDbtr', pretty_print=pretty_print)
        if self.ChrgBr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChrgBr>%s</%sChrgBr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChrgBr), input_name='ChrgBr')), namespace_, eol_))
        if self.ChrgsAcct is not None:
            self.ChrgsAcct.export(outfile, level, namespace_, name_='ChrgsAcct', pretty_print=pretty_print)
        for CdtTrfTxInf_ in self.CdtTrfTxInf:
            CdtTrfTxInf_.export(outfile, level, namespace_, name_='CdtTrfTxInf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PmtInfId':
            PmtInfId_ = child_.text
            PmtInfId_ = self.gds_validate_string(PmtInfId_, node, 'PmtInfId')
            self.PmtInfId = PmtInfId_
        elif nodeName_ == 'PmtMtd':
            PmtMtd_ = child_.text
            PmtMtd_ = self.gds_validate_string(PmtMtd_, node, 'PmtMtd')
            self.PmtMtd = PmtMtd_
            # validate type PaymentMethod3Code
            self.validate_PaymentMethod3Code(self.PmtMtd)
        elif nodeName_ == 'BtchBookg':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'BtchBookg')
            self.BtchBookg = ival_
            # validate type BatchBookingIndicator
            self.validate_BatchBookingIndicator(self.BtchBookg)
        elif nodeName_ == 'NbOfTxs':
            NbOfTxs_ = child_.text
            NbOfTxs_ = self.gds_validate_string(NbOfTxs_, node, 'NbOfTxs')
            self.NbOfTxs = NbOfTxs_
            # validate type Max15NumericText
            self.validate_Max15NumericText(self.NbOfTxs)
        elif nodeName_ == 'CtrlSum':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CtrlSum')
            self.CtrlSum = fval_
            # validate type DecimalNumber
            self.validate_DecimalNumber(self.CtrlSum)
        elif nodeName_ == 'PmtTpInf':
            obj_ = PaymentTypeInformation19_CH.factory()
            obj_.build(child_)
            self.PmtTpInf = obj_
            obj_.original_tagname_ = 'PmtTpInf'
        elif nodeName_ == 'ReqdExctnDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ReqdExctnDt = dval_
            # validate type ISODate
            self.validate_ISODate(self.ReqdExctnDt)
        elif nodeName_ == 'Dbtr':
            obj_ = PartyIdentification32_CH.factory()
            obj_.build(child_)
            self.Dbtr = obj_
            obj_.original_tagname_ = 'Dbtr'
        elif nodeName_ == 'DbtrAcct':
            obj_ = CashAccount16_CH_IdTpCcy.factory()
            obj_.build(child_)
            self.DbtrAcct = obj_
            obj_.original_tagname_ = 'DbtrAcct'
        elif nodeName_ == 'DbtrAgt':
            obj_ = BranchAndFinancialInstitutionIdentification4_CH_BicOrClrId.factory()
            obj_.build(child_)
            self.DbtrAgt = obj_
            obj_.original_tagname_ = 'DbtrAgt'
        elif nodeName_ == 'UltmtDbtr':
            obj_ = PartyIdentification32_CH.factory()
            obj_.build(child_)
            self.UltmtDbtr = obj_
            obj_.original_tagname_ = 'UltmtDbtr'
        elif nodeName_ == 'ChrgBr':
            ChrgBr_ = child_.text
            ChrgBr_ = self.gds_validate_string(ChrgBr_, node, 'ChrgBr')
            self.ChrgBr = ChrgBr_
            # validate type ChargeBearerType1Code
            self.validate_ChargeBearerType1Code(self.ChrgBr)
        elif nodeName_ == 'ChrgsAcct':
            obj_ = CashAccount16_CH_IdAndCurrency.factory()
            obj_.build(child_)
            self.ChrgsAcct = obj_
            obj_.original_tagname_ = 'ChrgsAcct'
        elif nodeName_ == 'CdtTrfTxInf':
            obj_ = CreditTransferTransactionInformation10_CH.factory()
            obj_.build(child_)
            self.CdtTrfTxInf.append(obj_)
            obj_.original_tagname_ = 'CdtTrfTxInf'
# end class PaymentInstructionInformation3_CH


class PaymentTypeInformation19_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InstrPrty=None, SvcLvl=None, LclInstrm=None, CtgyPurp=None):
        self.original_tagname_ = None
        self.InstrPrty = InstrPrty
        self.validate_Priority2Code(self.InstrPrty)
        self.SvcLvl = SvcLvl
        self.LclInstrm = LclInstrm
        self.CtgyPurp = CtgyPurp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentTypeInformation19_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentTypeInformation19_CH.subclass:
            return PaymentTypeInformation19_CH.subclass(*args_, **kwargs_)
        else:
            return PaymentTypeInformation19_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InstrPrty(self): return self.InstrPrty
    def set_InstrPrty(self, InstrPrty): self.InstrPrty = InstrPrty
    def get_SvcLvl(self): return self.SvcLvl
    def set_SvcLvl(self, SvcLvl): self.SvcLvl = SvcLvl
    def get_LclInstrm(self): return self.LclInstrm
    def set_LclInstrm(self, LclInstrm): self.LclInstrm = LclInstrm
    def get_CtgyPurp(self): return self.CtgyPurp
    def set_CtgyPurp(self, CtgyPurp): self.CtgyPurp = CtgyPurp
    def validate_Priority2Code(self, value):
        # Validate type Priority2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['HIGH', 'NORM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Priority2Code' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.InstrPrty is not None or
            self.SvcLvl is not None or
            self.LclInstrm is not None or
            self.CtgyPurp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentTypeInformation19-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentTypeInformation19-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentTypeInformation19-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentTypeInformation19-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentTypeInformation19-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InstrPrty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrPrty>%s</%sInstrPrty>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InstrPrty), input_name='InstrPrty')), namespace_, eol_))
        if self.SvcLvl is not None:
            self.SvcLvl.export(outfile, level, namespace_, name_='SvcLvl', pretty_print=pretty_print)
        if self.LclInstrm is not None:
            self.LclInstrm.export(outfile, level, namespace_, name_='LclInstrm', pretty_print=pretty_print)
        if self.CtgyPurp is not None:
            self.CtgyPurp.export(outfile, level, namespace_, name_='CtgyPurp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InstrPrty':
            InstrPrty_ = child_.text
            InstrPrty_ = self.gds_validate_string(InstrPrty_, node, 'InstrPrty')
            self.InstrPrty = InstrPrty_
            # validate type Priority2Code
            self.validate_Priority2Code(self.InstrPrty)
        elif nodeName_ == 'SvcLvl':
            obj_ = ServiceLevel8Choice.factory()
            obj_.build(child_)
            self.SvcLvl = obj_
            obj_.original_tagname_ = 'SvcLvl'
        elif nodeName_ == 'LclInstrm':
            obj_ = LocalInstrument2Choice.factory()
            obj_.build(child_)
            self.LclInstrm = obj_
            obj_.original_tagname_ = 'LclInstrm'
        elif nodeName_ == 'CtgyPurp':
            obj_ = CategoryPurpose1_CH_Code.factory()
            obj_.build(child_)
            self.CtgyPurp = obj_
            obj_.original_tagname_ = 'CtgyPurp'
# end class PaymentTypeInformation19_CH


class PersonIdentification5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DtAndPlcOfBirth=None, Othr=None):
        self.original_tagname_ = None
        self.DtAndPlcOfBirth = DtAndPlcOfBirth
        if Othr is None:
            self.Othr = []
        else:
            self.Othr = Othr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonIdentification5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonIdentification5.subclass:
            return PersonIdentification5.subclass(*args_, **kwargs_)
        else:
            return PersonIdentification5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DtAndPlcOfBirth(self): return self.DtAndPlcOfBirth
    def set_DtAndPlcOfBirth(self, DtAndPlcOfBirth): self.DtAndPlcOfBirth = DtAndPlcOfBirth
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def add_Othr(self, value): self.Othr.append(value)
    def insert_Othr_at(self, index, value): self.Othr.insert(index, value)
    def replace_Othr_at(self, index, value): self.Othr[index] = value
    def hasContent_(self):
        if (
            self.DtAndPlcOfBirth is not None or
            self.Othr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonIdentification5', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonIdentification5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonIdentification5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonIdentification5'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PersonIdentification5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DtAndPlcOfBirth is not None:
            self.DtAndPlcOfBirth.export(outfile, level, namespace_, name_='DtAndPlcOfBirth', pretty_print=pretty_print)
        for Othr_ in self.Othr:
            Othr_.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DtAndPlcOfBirth':
            obj_ = DateAndPlaceOfBirth.factory()
            obj_.build(child_)
            self.DtAndPlcOfBirth = obj_
            obj_.original_tagname_ = 'DtAndPlcOfBirth'
        elif nodeName_ == 'Othr':
            obj_ = GenericPersonIdentification1.factory()
            obj_.build(child_)
            self.Othr.append(obj_)
            obj_.original_tagname_ = 'Othr'
# end class PersonIdentification5


class PersonIdentification5_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DtAndPlcOfBirth=None, Othr=None):
        self.original_tagname_ = None
        self.DtAndPlcOfBirth = DtAndPlcOfBirth
        self.Othr = Othr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonIdentification5_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonIdentification5_CH.subclass:
            return PersonIdentification5_CH.subclass(*args_, **kwargs_)
        else:
            return PersonIdentification5_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DtAndPlcOfBirth(self): return self.DtAndPlcOfBirth
    def set_DtAndPlcOfBirth(self, DtAndPlcOfBirth): self.DtAndPlcOfBirth = DtAndPlcOfBirth
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def hasContent_(self):
        if (
            self.DtAndPlcOfBirth is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonIdentification5-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonIdentification5-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonIdentification5-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonIdentification5-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PersonIdentification5-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DtAndPlcOfBirth is not None:
            self.DtAndPlcOfBirth.export(outfile, level, namespace_, name_='DtAndPlcOfBirth', pretty_print=pretty_print)
        if self.Othr is not None:
            self.Othr.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DtAndPlcOfBirth':
            obj_ = DateAndPlaceOfBirth.factory()
            obj_.build(child_)
            self.DtAndPlcOfBirth = obj_
            obj_.original_tagname_ = 'DtAndPlcOfBirth'
        elif nodeName_ == 'Othr':
            obj_ = GenericPersonIdentification1.factory()
            obj_.build(child_)
            self.Othr = obj_
            obj_.original_tagname_ = 'Othr'
# end class PersonIdentification5_CH


class PersonIdentificationSchemeName1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalPersonIdentification1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonIdentificationSchemeName1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonIdentificationSchemeName1Choice.subclass:
            return PersonIdentificationSchemeName1Choice.subclass(*args_, **kwargs_)
        else:
            return PersonIdentificationSchemeName1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalPersonIdentification1Code(self, value):
        # Validate type ExternalPersonIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalPersonIdentification1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalPersonIdentification1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonIdentificationSchemeName1Choice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonIdentificationSchemeName1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonIdentificationSchemeName1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonIdentificationSchemeName1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PersonIdentificationSchemeName1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            self.Prtry.export(outfile, level, namespace_, name_='Prtry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalPersonIdentification1Code
            self.validate_ExternalPersonIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            obj_ = None
            self.Prtry = obj_
            obj_.original_tagname_ = 'Prtry'
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class PersonIdentificationSchemeName1Choice


class PostalAddress6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AdrTp=None, Dept=None, SubDept=None, StrtNm=None, BldgNb=None, PstCd=None, TwnNm=None, CtrySubDvsn=None, Ctry=None, AdrLine=None):
        self.original_tagname_ = None
        self.AdrTp = AdrTp
        self.validate_AddressType2Code(self.AdrTp)
        self.Dept = Dept
        self.validate_Max70Text(self.Dept)
        self.SubDept = SubDept
        self.validate_Max70Text(self.SubDept)
        self.StrtNm = StrtNm
        self.validate_Max70Text(self.StrtNm)
        self.BldgNb = BldgNb
        self.validate_Max16Text(self.BldgNb)
        self.PstCd = PstCd
        self.validate_Max16Text(self.PstCd)
        self.TwnNm = TwnNm
        self.validate_Max35Text(self.TwnNm)
        self.CtrySubDvsn = CtrySubDvsn
        self.validate_Max35Text(self.CtrySubDvsn)
        self.Ctry = Ctry
        self.validate_CountryCode(self.Ctry)
        if AdrLine is None:
            self.AdrLine = []
        else:
            self.AdrLine = AdrLine
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PostalAddress6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PostalAddress6.subclass:
            return PostalAddress6.subclass(*args_, **kwargs_)
        else:
            return PostalAddress6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdrTp(self): return self.AdrTp
    def set_AdrTp(self, AdrTp): self.AdrTp = AdrTp
    def get_Dept(self): return self.Dept
    def set_Dept(self, Dept): self.Dept = Dept
    def get_SubDept(self): return self.SubDept
    def set_SubDept(self, SubDept): self.SubDept = SubDept
    def get_StrtNm(self): return self.StrtNm
    def set_StrtNm(self, StrtNm): self.StrtNm = StrtNm
    def get_BldgNb(self): return self.BldgNb
    def set_BldgNb(self, BldgNb): self.BldgNb = BldgNb
    def get_PstCd(self): return self.PstCd
    def set_PstCd(self, PstCd): self.PstCd = PstCd
    def get_TwnNm(self): return self.TwnNm
    def set_TwnNm(self, TwnNm): self.TwnNm = TwnNm
    def get_CtrySubDvsn(self): return self.CtrySubDvsn
    def set_CtrySubDvsn(self, CtrySubDvsn): self.CtrySubDvsn = CtrySubDvsn
    def get_Ctry(self): return self.Ctry
    def set_Ctry(self, Ctry): self.Ctry = Ctry
    def get_AdrLine(self): return self.AdrLine
    def set_AdrLine(self, AdrLine): self.AdrLine = AdrLine
    def add_AdrLine(self, value): self.AdrLine.append(value)
    def insert_AdrLine_at(self, index, value): self.AdrLine.insert(index, value)
    def replace_AdrLine_at(self, index, value): self.AdrLine[index] = value
    def validate_AddressType2Code(self, value):
        # Validate type AddressType2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ADDR', 'PBOX', 'HOME', 'BIZZ', 'MLTO', 'DLVY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressType2Code' % {"value" : value.encode("utf-8")} )
    def validate_Max70Text(self, value):
        # Validate type Max70Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max70Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max70Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max70Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max70Text_patterns_, ))
    validate_Max70Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_Max16Text(self, value):
        # Validate type Max16Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 16:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max16Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max16Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max16Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max16Text_patterns_, ))
    validate_Max16Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CountryCode_patterns_, ))
    validate_CountryCode_patterns_ = [['^[A-Z]{2,2}$']]
    def hasContent_(self):
        if (
            self.AdrTp is not None or
            self.Dept is not None or
            self.SubDept is not None or
            self.StrtNm is not None or
            self.BldgNb is not None or
            self.PstCd is not None or
            self.TwnNm is not None or
            self.CtrySubDvsn is not None or
            self.Ctry is not None or
            self.AdrLine
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PostalAddress6', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PostalAddress6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PostalAddress6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PostalAddress6'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PostalAddress6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AdrTp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdrTp>%s</%sAdrTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AdrTp), input_name='AdrTp')), namespace_, eol_))
        if self.Dept is not None:
            self.Dept.export(outfile, level, namespace_, name_='Dept', pretty_print=pretty_print)
        if self.SubDept is not None:
            self.SubDept.export(outfile, level, namespace_, name_='SubDept', pretty_print=pretty_print)
        if self.StrtNm is not None:
            self.StrtNm.export(outfile, level, namespace_, name_='StrtNm', pretty_print=pretty_print)
        if self.BldgNb is not None:
            self.BldgNb.export(outfile, level, namespace_, name_='BldgNb', pretty_print=pretty_print)
        if self.PstCd is not None:
            self.PstCd.export(outfile, level, namespace_, name_='PstCd', pretty_print=pretty_print)
        if self.TwnNm is not None:
            self.TwnNm.export(outfile, level, namespace_, name_='TwnNm', pretty_print=pretty_print)
        if self.CtrySubDvsn is not None:
            self.CtrySubDvsn.export(outfile, level, namespace_, name_='CtrySubDvsn', pretty_print=pretty_print)
        if self.Ctry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtry>%s</%sCtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ctry), input_name='Ctry')), namespace_, eol_))
        for AdrLine_ in self.AdrLine:
            AdrLine_.export(outfile, level, namespace_, name_='AdrLine', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdrTp':
            AdrTp_ = child_.text
            AdrTp_ = self.gds_validate_string(AdrTp_, node, 'AdrTp')
            self.AdrTp = AdrTp_
            # validate type AddressType2Code
            self.validate_AddressType2Code(self.AdrTp)
        elif nodeName_ == 'Dept':
            obj_ = None
            self.Dept = obj_
            obj_.original_tagname_ = 'Dept'
            # validate type Max70Text
            self.validate_Max70Text(self.Dept)
        elif nodeName_ == 'SubDept':
            obj_ = None
            self.SubDept = obj_
            obj_.original_tagname_ = 'SubDept'
            # validate type Max70Text
            self.validate_Max70Text(self.SubDept)
        elif nodeName_ == 'StrtNm':
            obj_ = None
            self.StrtNm = obj_
            obj_.original_tagname_ = 'StrtNm'
            # validate type Max70Text
            self.validate_Max70Text(self.StrtNm)
        elif nodeName_ == 'BldgNb':
            obj_ = None
            self.BldgNb = obj_
            obj_.original_tagname_ = 'BldgNb'
            # validate type Max16Text
            self.validate_Max16Text(self.BldgNb)
        elif nodeName_ == 'PstCd':
            obj_ = None
            self.PstCd = obj_
            obj_.original_tagname_ = 'PstCd'
            # validate type Max16Text
            self.validate_Max16Text(self.PstCd)
        elif nodeName_ == 'TwnNm':
            obj_ = None
            self.TwnNm = obj_
            obj_.original_tagname_ = 'TwnNm'
            # validate type Max35Text
            self.validate_Max35Text(self.TwnNm)
        elif nodeName_ == 'CtrySubDvsn':
            obj_ = None
            self.CtrySubDvsn = obj_
            obj_.original_tagname_ = 'CtrySubDvsn'
            # validate type Max35Text
            self.validate_Max35Text(self.CtrySubDvsn)
        elif nodeName_ == 'Ctry':
            Ctry_ = child_.text
            Ctry_ = self.gds_validate_string(Ctry_, node, 'Ctry')
            self.Ctry = Ctry_
            # validate type CountryCode
            self.validate_CountryCode(self.Ctry)
        elif nodeName_ == 'AdrLine':
            obj_ = None
            self.AdrLine.append(obj_)
            obj_.original_tagname_ = 'AdrLine'
            # validate type Max70Text
            self.validate_Max70Text(self.AdrLine[-1])
# end class PostalAddress6


class PostalAddress6_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AdrTp=None, Dept=None, SubDept=None, StrtNm=None, BldgNb=None, PstCd=None, TwnNm=None, CtrySubDvsn=None, Ctry=None, AdrLine=None):
        self.original_tagname_ = None
        self.AdrTp = AdrTp
        self.validate_AddressType2Code(self.AdrTp)
        self.Dept = Dept
        self.validate_Max70Text(self.Dept)
        self.SubDept = SubDept
        self.validate_Max70Text(self.SubDept)
        self.StrtNm = StrtNm
        self.validate_Max70Text(self.StrtNm)
        self.BldgNb = BldgNb
        self.validate_Max16Text(self.BldgNb)
        self.PstCd = PstCd
        self.validate_Max16Text(self.PstCd)
        self.TwnNm = TwnNm
        self.validate_Max35Text(self.TwnNm)
        self.CtrySubDvsn = CtrySubDvsn
        self.validate_Max35Text(self.CtrySubDvsn)
        self.Ctry = Ctry
        self.validate_CountryCode(self.Ctry)
        if AdrLine is None:
            self.AdrLine = []
        else:
            self.AdrLine = AdrLine
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PostalAddress6_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PostalAddress6_CH.subclass:
            return PostalAddress6_CH.subclass(*args_, **kwargs_)
        else:
            return PostalAddress6_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdrTp(self): return self.AdrTp
    def set_AdrTp(self, AdrTp): self.AdrTp = AdrTp
    def get_Dept(self): return self.Dept
    def set_Dept(self, Dept): self.Dept = Dept
    def get_SubDept(self): return self.SubDept
    def set_SubDept(self, SubDept): self.SubDept = SubDept
    def get_StrtNm(self): return self.StrtNm
    def set_StrtNm(self, StrtNm): self.StrtNm = StrtNm
    def get_BldgNb(self): return self.BldgNb
    def set_BldgNb(self, BldgNb): self.BldgNb = BldgNb
    def get_PstCd(self): return self.PstCd
    def set_PstCd(self, PstCd): self.PstCd = PstCd
    def get_TwnNm(self): return self.TwnNm
    def set_TwnNm(self, TwnNm): self.TwnNm = TwnNm
    def get_CtrySubDvsn(self): return self.CtrySubDvsn
    def set_CtrySubDvsn(self, CtrySubDvsn): self.CtrySubDvsn = CtrySubDvsn
    def get_Ctry(self): return self.Ctry
    def set_Ctry(self, Ctry): self.Ctry = Ctry
    def get_AdrLine(self): return self.AdrLine
    def set_AdrLine(self, AdrLine): self.AdrLine = AdrLine
    def add_AdrLine(self, value): self.AdrLine.append(value)
    def insert_AdrLine_at(self, index, value): self.AdrLine.insert(index, value)
    def replace_AdrLine_at(self, index, value): self.AdrLine[index] = value
    def validate_AddressType2Code(self, value):
        # Validate type AddressType2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ADDR', 'PBOX', 'HOME', 'BIZZ', 'MLTO', 'DLVY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressType2Code' % {"value" : value.encode("utf-8")} )
    def validate_Max70Text(self, value):
        # Validate type Max70Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max70Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max70Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max70Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max70Text_patterns_, ))
    validate_Max70Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_Max16Text(self, value):
        # Validate type Max16Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 16:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max16Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max16Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max16Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max16Text_patterns_, ))
    validate_Max16Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CountryCode_patterns_, ))
    validate_CountryCode_patterns_ = [['^[A-Z]{2,2}$']]
    def hasContent_(self):
        if (
            self.AdrTp is not None or
            self.Dept is not None or
            self.SubDept is not None or
            self.StrtNm is not None or
            self.BldgNb is not None or
            self.PstCd is not None or
            self.TwnNm is not None or
            self.CtrySubDvsn is not None or
            self.Ctry is not None or
            self.AdrLine
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PostalAddress6-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PostalAddress6-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PostalAddress6-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PostalAddress6-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PostalAddress6-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AdrTp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdrTp>%s</%sAdrTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AdrTp), input_name='AdrTp')), namespace_, eol_))
        if self.Dept is not None:
            self.Dept.export(outfile, level, namespace_, name_='Dept', pretty_print=pretty_print)
        if self.SubDept is not None:
            self.SubDept.export(outfile, level, namespace_, name_='SubDept', pretty_print=pretty_print)
        if self.StrtNm is not None:
            self.StrtNm.export(outfile, level, namespace_, name_='StrtNm', pretty_print=pretty_print)
        if self.BldgNb is not None:
            self.BldgNb.export(outfile, level, namespace_, name_='BldgNb', pretty_print=pretty_print)
        if self.PstCd is not None:
            self.PstCd.export(outfile, level, namespace_, name_='PstCd', pretty_print=pretty_print)
        if self.TwnNm is not None:
            self.TwnNm.export(outfile, level, namespace_, name_='TwnNm', pretty_print=pretty_print)
        if self.CtrySubDvsn is not None:
            self.CtrySubDvsn.export(outfile, level, namespace_, name_='CtrySubDvsn', pretty_print=pretty_print)
        if self.Ctry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtry>%s</%sCtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ctry), input_name='Ctry')), namespace_, eol_))
        for AdrLine_ in self.AdrLine:
            AdrLine_.export(outfile, level, namespace_, name_='AdrLine', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdrTp':
            AdrTp_ = child_.text
            AdrTp_ = self.gds_validate_string(AdrTp_, node, 'AdrTp')
            self.AdrTp = AdrTp_
            # validate type AddressType2Code
            self.validate_AddressType2Code(self.AdrTp)
        elif nodeName_ == 'Dept':
            obj_ = None
            self.Dept = obj_
            obj_.original_tagname_ = 'Dept'
            # validate type Max70Text
            self.validate_Max70Text(self.Dept)
        elif nodeName_ == 'SubDept':
            obj_ = None
            self.SubDept = obj_
            obj_.original_tagname_ = 'SubDept'
            # validate type Max70Text
            self.validate_Max70Text(self.SubDept)
        elif nodeName_ == 'StrtNm':
            obj_ = None
            self.StrtNm = obj_
            obj_.original_tagname_ = 'StrtNm'
            # validate type Max70Text
            self.validate_Max70Text(self.StrtNm)
        elif nodeName_ == 'BldgNb':
            obj_ = None
            self.BldgNb = obj_
            obj_.original_tagname_ = 'BldgNb'
            # validate type Max16Text
            self.validate_Max16Text(self.BldgNb)
        elif nodeName_ == 'PstCd':
            obj_ = None
            self.PstCd = obj_
            obj_.original_tagname_ = 'PstCd'
            # validate type Max16Text
            self.validate_Max16Text(self.PstCd)
        elif nodeName_ == 'TwnNm':
            obj_ = None
            self.TwnNm = obj_
            obj_.original_tagname_ = 'TwnNm'
            # validate type Max35Text
            self.validate_Max35Text(self.TwnNm)
        elif nodeName_ == 'CtrySubDvsn':
            obj_ = None
            self.CtrySubDvsn = obj_
            obj_.original_tagname_ = 'CtrySubDvsn'
            # validate type Max35Text
            self.validate_Max35Text(self.CtrySubDvsn)
        elif nodeName_ == 'Ctry':
            Ctry_ = child_.text
            Ctry_ = self.gds_validate_string(Ctry_, node, 'Ctry')
            self.Ctry = Ctry_
            # validate type CountryCode
            self.validate_CountryCode(self.Ctry)
        elif nodeName_ == 'AdrLine':
            obj_ = None
            self.AdrLine.append(obj_)
            obj_.original_tagname_ = 'AdrLine'
            # validate type Max70Text
            self.validate_Max70Text(self.AdrLine[-1])
# end class PostalAddress6_CH


class Purpose2_CH_Code(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalPurpose1Code(self.Cd)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Purpose2_CH_Code)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Purpose2_CH_Code.subclass:
            return Purpose2_CH_Code.subclass(*args_, **kwargs_)
        else:
            return Purpose2_CH_Code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def validate_ExternalPurpose1Code(self, value):
        # Validate type ExternalPurpose1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalPurpose1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalPurpose1Code' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Purpose2-CH_Code', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Purpose2-CH_Code')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Purpose2-CH_Code', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Purpose2-CH_Code'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Purpose2-CH_Code', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalPurpose1Code
            self.validate_ExternalPurpose1Code(self.Cd)
# end class Purpose2_CH_Code


class ReferredDocumentInformation3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Nb=None, RltdDt=None):
        self.original_tagname_ = None
        self.Tp = Tp
        self.Nb = Nb
        self.validate_Max35Text(self.Nb)
        if isinstance(RltdDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RltdDt, '%Y-%m-%d').date()
        else:
            initvalue_ = RltdDt
        self.RltdDt = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferredDocumentInformation3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferredDocumentInformation3.subclass:
            return ReferredDocumentInformation3.subclass(*args_, **kwargs_)
        else:
            return ReferredDocumentInformation3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tp(self): return self.Tp
    def set_Tp(self, Tp): self.Tp = Tp
    def get_Nb(self): return self.Nb
    def set_Nb(self, Nb): self.Nb = Nb
    def get_RltdDt(self): return self.RltdDt
    def set_RltdDt(self, RltdDt): self.RltdDt = RltdDt
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Tp is not None or
            self.Nb is not None or
            self.RltdDt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferredDocumentInformation3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferredDocumentInformation3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferredDocumentInformation3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferredDocumentInformation3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferredDocumentInformation3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            self.Tp.export(outfile, level, namespace_, name_='Tp', pretty_print=pretty_print)
        if self.Nb is not None:
            self.Nb.export(outfile, level, namespace_, name_='Nb', pretty_print=pretty_print)
        if self.RltdDt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRltdDt>%s</%sRltdDt>%s' % (namespace_, self.gds_format_date(self.RltdDt, input_name='RltdDt'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tp':
            obj_ = ReferredDocumentType2.factory()
            obj_.build(child_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Nb':
            obj_ = None
            self.Nb = obj_
            obj_.original_tagname_ = 'Nb'
            # validate type Max35Text
            self.validate_Max35Text(self.Nb)
        elif nodeName_ == 'RltdDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.RltdDt = dval_
            # validate type ISODate
            self.validate_ISODate(self.RltdDt)
# end class ReferredDocumentInformation3


class ReferredDocumentType1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_DocumentType5Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferredDocumentType1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferredDocumentType1Choice.subclass:
            return ReferredDocumentType1Choice.subclass(*args_, **kwargs_)
        else:
            return ReferredDocumentType1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_DocumentType5Code(self, value):
        # Validate type DocumentType5Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MSIN', 'CNFA', 'DNFA', 'CINV', 'CREN', 'DEBN', 'HIRI', 'SBIN', 'CMCN', 'SOAC', 'DISP', 'BOLD', 'VCHR', 'AROI', 'TSUT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DocumentType5Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferredDocumentType1Choice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferredDocumentType1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferredDocumentType1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferredDocumentType1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferredDocumentType1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            self.Prtry.export(outfile, level, namespace_, name_='Prtry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type DocumentType5Code
            self.validate_DocumentType5Code(self.Cd)
        elif nodeName_ == 'Prtry':
            obj_ = None
            self.Prtry = obj_
            obj_.original_tagname_ = 'Prtry'
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ReferredDocumentType1Choice


class ReferredDocumentType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CdOrPrtry=None, Issr=None):
        self.original_tagname_ = None
        self.CdOrPrtry = CdOrPrtry
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferredDocumentType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferredDocumentType2.subclass:
            return ReferredDocumentType2.subclass(*args_, **kwargs_)
        else:
            return ReferredDocumentType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CdOrPrtry(self): return self.CdOrPrtry
    def set_CdOrPrtry(self, CdOrPrtry): self.CdOrPrtry = CdOrPrtry
    def get_Issr(self): return self.Issr
    def set_Issr(self, Issr): self.Issr = Issr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.CdOrPrtry is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferredDocumentType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferredDocumentType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferredDocumentType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferredDocumentType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferredDocumentType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CdOrPrtry is not None:
            self.CdOrPrtry.export(outfile, level, namespace_, name_='CdOrPrtry', pretty_print=pretty_print)
        if self.Issr is not None:
            self.Issr.export(outfile, level, namespace_, name_='Issr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CdOrPrtry':
            obj_ = ReferredDocumentType1Choice.factory()
            obj_.build(child_)
            self.CdOrPrtry = obj_
            obj_.original_tagname_ = 'CdOrPrtry'
        elif nodeName_ == 'Issr':
            obj_ = None
            self.Issr = obj_
            obj_.original_tagname_ = 'Issr'
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class ReferredDocumentType2


class RegulatoryAuthority2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Nm=None, Ctry=None):
        self.original_tagname_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.Ctry = Ctry
        self.validate_CountryCode(self.Ctry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegulatoryAuthority2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegulatoryAuthority2.subclass:
            return RegulatoryAuthority2.subclass(*args_, **kwargs_)
        else:
            return RegulatoryAuthority2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_Ctry(self): return self.Ctry
    def set_Ctry(self, Ctry): self.Ctry = Ctry
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max140Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max140Text_patterns_, ))
    validate_Max140Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CountryCode_patterns_, ))
    validate_CountryCode_patterns_ = [['^[A-Z]{2,2}$']]
    def hasContent_(self):
        if (
            self.Nm is not None or
            self.Ctry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegulatoryAuthority2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegulatoryAuthority2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RegulatoryAuthority2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegulatoryAuthority2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegulatoryAuthority2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            self.Nm.export(outfile, level, namespace_, name_='Nm', pretty_print=pretty_print)
        if self.Ctry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtry>%s</%sCtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ctry), input_name='Ctry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nm':
            obj_ = None
            self.Nm = obj_
            obj_.original_tagname_ = 'Nm'
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'Ctry':
            Ctry_ = child_.text
            Ctry_ = self.gds_validate_string(Ctry_, node, 'Ctry')
            self.Ctry = Ctry_
            # validate type CountryCode
            self.validate_CountryCode(self.Ctry)
# end class RegulatoryAuthority2


class RegulatoryReporting3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DbtCdtRptgInd=None, Authrty=None, Dtls=None):
        self.original_tagname_ = None
        self.DbtCdtRptgInd = DbtCdtRptgInd
        self.validate_RegulatoryReportingType1Code(self.DbtCdtRptgInd)
        self.Authrty = Authrty
        if Dtls is None:
            self.Dtls = []
        else:
            self.Dtls = Dtls
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegulatoryReporting3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegulatoryReporting3.subclass:
            return RegulatoryReporting3.subclass(*args_, **kwargs_)
        else:
            return RegulatoryReporting3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DbtCdtRptgInd(self): return self.DbtCdtRptgInd
    def set_DbtCdtRptgInd(self, DbtCdtRptgInd): self.DbtCdtRptgInd = DbtCdtRptgInd
    def get_Authrty(self): return self.Authrty
    def set_Authrty(self, Authrty): self.Authrty = Authrty
    def get_Dtls(self): return self.Dtls
    def set_Dtls(self, Dtls): self.Dtls = Dtls
    def add_Dtls(self, value): self.Dtls.append(value)
    def insert_Dtls_at(self, index, value): self.Dtls.insert(index, value)
    def replace_Dtls_at(self, index, value): self.Dtls[index] = value
    def validate_RegulatoryReportingType1Code(self, value):
        # Validate type RegulatoryReportingType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CRED', 'DEBT', 'BOTH']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RegulatoryReportingType1Code' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.DbtCdtRptgInd is not None or
            self.Authrty is not None or
            self.Dtls
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegulatoryReporting3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegulatoryReporting3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RegulatoryReporting3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegulatoryReporting3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegulatoryReporting3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DbtCdtRptgInd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDbtCdtRptgInd>%s</%sDbtCdtRptgInd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DbtCdtRptgInd), input_name='DbtCdtRptgInd')), namespace_, eol_))
        if self.Authrty is not None:
            self.Authrty.export(outfile, level, namespace_, name_='Authrty', pretty_print=pretty_print)
        for Dtls_ in self.Dtls:
            Dtls_.export(outfile, level, namespace_, name_='Dtls', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DbtCdtRptgInd':
            DbtCdtRptgInd_ = child_.text
            DbtCdtRptgInd_ = self.gds_validate_string(DbtCdtRptgInd_, node, 'DbtCdtRptgInd')
            self.DbtCdtRptgInd = DbtCdtRptgInd_
            # validate type RegulatoryReportingType1Code
            self.validate_RegulatoryReportingType1Code(self.DbtCdtRptgInd)
        elif nodeName_ == 'Authrty':
            obj_ = RegulatoryAuthority2.factory()
            obj_.build(child_)
            self.Authrty = obj_
            obj_.original_tagname_ = 'Authrty'
        elif nodeName_ == 'Dtls':
            obj_ = StructuredRegulatoryReporting3.factory()
            obj_.build(child_)
            self.Dtls.append(obj_)
            obj_.original_tagname_ = 'Dtls'
# end class RegulatoryReporting3


class RemittanceAmount1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DuePyblAmt=None, DscntApldAmt=None, CdtNoteAmt=None, TaxAmt=None, AdjstmntAmtAndRsn=None, RmtdAmt=None):
        self.original_tagname_ = None
        self.DuePyblAmt = DuePyblAmt
        self.DscntApldAmt = DscntApldAmt
        self.CdtNoteAmt = CdtNoteAmt
        self.TaxAmt = TaxAmt
        if AdjstmntAmtAndRsn is None:
            self.AdjstmntAmtAndRsn = []
        else:
            self.AdjstmntAmtAndRsn = AdjstmntAmtAndRsn
        self.RmtdAmt = RmtdAmt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemittanceAmount1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemittanceAmount1.subclass:
            return RemittanceAmount1.subclass(*args_, **kwargs_)
        else:
            return RemittanceAmount1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DuePyblAmt(self): return self.DuePyblAmt
    def set_DuePyblAmt(self, DuePyblAmt): self.DuePyblAmt = DuePyblAmt
    def get_DscntApldAmt(self): return self.DscntApldAmt
    def set_DscntApldAmt(self, DscntApldAmt): self.DscntApldAmt = DscntApldAmt
    def get_CdtNoteAmt(self): return self.CdtNoteAmt
    def set_CdtNoteAmt(self, CdtNoteAmt): self.CdtNoteAmt = CdtNoteAmt
    def get_TaxAmt(self): return self.TaxAmt
    def set_TaxAmt(self, TaxAmt): self.TaxAmt = TaxAmt
    def get_AdjstmntAmtAndRsn(self): return self.AdjstmntAmtAndRsn
    def set_AdjstmntAmtAndRsn(self, AdjstmntAmtAndRsn): self.AdjstmntAmtAndRsn = AdjstmntAmtAndRsn
    def add_AdjstmntAmtAndRsn(self, value): self.AdjstmntAmtAndRsn.append(value)
    def insert_AdjstmntAmtAndRsn_at(self, index, value): self.AdjstmntAmtAndRsn.insert(index, value)
    def replace_AdjstmntAmtAndRsn_at(self, index, value): self.AdjstmntAmtAndRsn[index] = value
    def get_RmtdAmt(self): return self.RmtdAmt
    def set_RmtdAmt(self, RmtdAmt): self.RmtdAmt = RmtdAmt
    def hasContent_(self):
        if (
            self.DuePyblAmt is not None or
            self.DscntApldAmt is not None or
            self.CdtNoteAmt is not None or
            self.TaxAmt is not None or
            self.AdjstmntAmtAndRsn or
            self.RmtdAmt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RemittanceAmount1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RemittanceAmount1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RemittanceAmount1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RemittanceAmount1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RemittanceAmount1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DuePyblAmt is not None:
            self.DuePyblAmt.export(outfile, level, namespace_, name_='DuePyblAmt', pretty_print=pretty_print)
        if self.DscntApldAmt is not None:
            self.DscntApldAmt.export(outfile, level, namespace_, name_='DscntApldAmt', pretty_print=pretty_print)
        if self.CdtNoteAmt is not None:
            self.CdtNoteAmt.export(outfile, level, namespace_, name_='CdtNoteAmt', pretty_print=pretty_print)
        if self.TaxAmt is not None:
            self.TaxAmt.export(outfile, level, namespace_, name_='TaxAmt', pretty_print=pretty_print)
        for AdjstmntAmtAndRsn_ in self.AdjstmntAmtAndRsn:
            AdjstmntAmtAndRsn_.export(outfile, level, namespace_, name_='AdjstmntAmtAndRsn', pretty_print=pretty_print)
        if self.RmtdAmt is not None:
            self.RmtdAmt.export(outfile, level, namespace_, name_='RmtdAmt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DuePyblAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.DuePyblAmt = obj_
            obj_.original_tagname_ = 'DuePyblAmt'
        elif nodeName_ == 'DscntApldAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.DscntApldAmt = obj_
            obj_.original_tagname_ = 'DscntApldAmt'
        elif nodeName_ == 'CdtNoteAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.CdtNoteAmt = obj_
            obj_.original_tagname_ = 'CdtNoteAmt'
        elif nodeName_ == 'TaxAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.TaxAmt = obj_
            obj_.original_tagname_ = 'TaxAmt'
        elif nodeName_ == 'AdjstmntAmtAndRsn':
            obj_ = DocumentAdjustment1.factory()
            obj_.build(child_)
            self.AdjstmntAmtAndRsn.append(obj_)
            obj_.original_tagname_ = 'AdjstmntAmtAndRsn'
        elif nodeName_ == 'RmtdAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.RmtdAmt = obj_
            obj_.original_tagname_ = 'RmtdAmt'
# end class RemittanceAmount1


class RemittanceInformation5_CH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Ustrd=None, Strd=None):
        self.original_tagname_ = None
        self.Ustrd = Ustrd
        self.validate_Max140Text(self.Ustrd)
        self.Strd = Strd
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemittanceInformation5_CH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemittanceInformation5_CH.subclass:
            return RemittanceInformation5_CH.subclass(*args_, **kwargs_)
        else:
            return RemittanceInformation5_CH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ustrd(self): return self.Ustrd
    def set_Ustrd(self, Ustrd): self.Ustrd = Ustrd
    def get_Strd(self): return self.Strd
    def set_Strd(self, Strd): self.Strd = Strd
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max140Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max140Text_patterns_, ))
    validate_Max140Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Ustrd is not None or
            self.Strd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RemittanceInformation5-CH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RemittanceInformation5-CH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RemittanceInformation5-CH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RemittanceInformation5-CH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RemittanceInformation5-CH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Ustrd is not None:
            self.Ustrd.export(outfile, level, namespace_, name_='Ustrd', pretty_print=pretty_print)
        if self.Strd is not None:
            self.Strd.export(outfile, level, namespace_, name_='Strd', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Ustrd':
            obj_ = None
            self.Ustrd = obj_
            obj_.original_tagname_ = 'Ustrd'
            # validate type Max140Text
            self.validate_Max140Text(self.Ustrd)
        elif nodeName_ == 'Strd':
            obj_ = StructuredRemittanceInformation7.factory()
            obj_.build(child_)
            self.Strd = obj_
            obj_.original_tagname_ = 'Strd'
# end class RemittanceInformation5_CH


class ServiceLevel8Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalServiceLevel1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceLevel8Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceLevel8Choice.subclass:
            return ServiceLevel8Choice.subclass(*args_, **kwargs_)
        else:
            return ServiceLevel8Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalServiceLevel1Code(self, value):
        # Validate type ExternalServiceLevel1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalServiceLevel1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalServiceLevel1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceLevel8Choice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceLevel8Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceLevel8Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceLevel8Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceLevel8Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            self.Prtry.export(outfile, level, namespace_, name_='Prtry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalServiceLevel1Code
            self.validate_ExternalServiceLevel1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            obj_ = None
            self.Prtry = obj_
            obj_.original_tagname_ = 'Prtry'
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ServiceLevel8Choice


class StructuredRegulatoryReporting3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Dt=None, Ctry=None, Cd=None, Amt=None, Inf=None):
        self.original_tagname_ = None
        self.Tp = Tp
        self.validate_Max35Text(self.Tp)
        if isinstance(Dt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Dt, '%Y-%m-%d').date()
        else:
            initvalue_ = Dt
        self.Dt = initvalue_
        self.Ctry = Ctry
        self.validate_CountryCode(self.Ctry)
        self.Cd = Cd
        self.validate_Max10Text(self.Cd)
        self.Amt = Amt
        if Inf is None:
            self.Inf = []
        else:
            self.Inf = Inf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StructuredRegulatoryReporting3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StructuredRegulatoryReporting3.subclass:
            return StructuredRegulatoryReporting3.subclass(*args_, **kwargs_)
        else:
            return StructuredRegulatoryReporting3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tp(self): return self.Tp
    def set_Tp(self, Tp): self.Tp = Tp
    def get_Dt(self): return self.Dt
    def set_Dt(self, Dt): self.Dt = Dt
    def get_Ctry(self): return self.Ctry
    def set_Ctry(self, Ctry): self.Ctry = Ctry
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Amt(self): return self.Amt
    def set_Amt(self, Amt): self.Amt = Amt
    def get_Inf(self): return self.Inf
    def set_Inf(self, Inf): self.Inf = Inf
    def add_Inf(self, value): self.Inf.append(value)
    def insert_Inf_at(self, index, value): self.Inf.insert(index, value)
    def replace_Inf_at(self, index, value): self.Inf[index] = value
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max35Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max35Text_patterns_, ))
    validate_Max35Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CountryCode_patterns_, ))
    validate_CountryCode_patterns_ = [['^[A-Z]{2,2}$']]
    def validate_Max10Text(self, value):
        # Validate type Max10Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max10Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max10Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max10Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max10Text_patterns_, ))
    validate_Max10Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.Tp is not None or
            self.Dt is not None or
            self.Ctry is not None or
            self.Cd is not None or
            self.Amt is not None or
            self.Inf
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StructuredRegulatoryReporting3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructuredRegulatoryReporting3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StructuredRegulatoryReporting3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StructuredRegulatoryReporting3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StructuredRegulatoryReporting3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            self.Tp.export(outfile, level, namespace_, name_='Tp', pretty_print=pretty_print)
        if self.Dt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDt>%s</%sDt>%s' % (namespace_, self.gds_format_date(self.Dt, input_name='Dt'), namespace_, eol_))
        if self.Ctry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtry>%s</%sCtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ctry), input_name='Ctry')), namespace_, eol_))
        if self.Cd is not None:
            self.Cd.export(outfile, level, namespace_, name_='Cd', pretty_print=pretty_print)
        if self.Amt is not None:
            self.Amt.export(outfile, level, namespace_, name_='Amt', pretty_print=pretty_print)
        for Inf_ in self.Inf:
            Inf_.export(outfile, level, namespace_, name_='Inf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tp':
            obj_ = None
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
            # validate type Max35Text
            self.validate_Max35Text(self.Tp)
        elif nodeName_ == 'Dt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Dt = dval_
            # validate type ISODate
            self.validate_ISODate(self.Dt)
        elif nodeName_ == 'Ctry':
            Ctry_ = child_.text
            Ctry_ = self.gds_validate_string(Ctry_, node, 'Ctry')
            self.Ctry = Ctry_
            # validate type CountryCode
            self.validate_CountryCode(self.Ctry)
        elif nodeName_ == 'Cd':
            obj_ = None
            self.Cd = obj_
            obj_.original_tagname_ = 'Cd'
            # validate type Max10Text
            self.validate_Max10Text(self.Cd)
        elif nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
        elif nodeName_ == 'Inf':
            obj_ = None
            self.Inf.append(obj_)
            obj_.original_tagname_ = 'Inf'
            # validate type Max35Text
            self.validate_Max35Text(self.Inf[-1])
# end class StructuredRegulatoryReporting3


class StructuredRemittanceInformation7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RfrdDocInf=None, RfrdDocAmt=None, CdtrRefInf=None, Invcr=None, Invcee=None, AddtlRmtInf=None):
        self.original_tagname_ = None
        if RfrdDocInf is None:
            self.RfrdDocInf = []
        else:
            self.RfrdDocInf = RfrdDocInf
        self.RfrdDocAmt = RfrdDocAmt
        self.CdtrRefInf = CdtrRefInf
        self.Invcr = Invcr
        self.Invcee = Invcee
        if AddtlRmtInf is None:
            self.AddtlRmtInf = []
        else:
            self.AddtlRmtInf = AddtlRmtInf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StructuredRemittanceInformation7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StructuredRemittanceInformation7.subclass:
            return StructuredRemittanceInformation7.subclass(*args_, **kwargs_)
        else:
            return StructuredRemittanceInformation7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RfrdDocInf(self): return self.RfrdDocInf
    def set_RfrdDocInf(self, RfrdDocInf): self.RfrdDocInf = RfrdDocInf
    def add_RfrdDocInf(self, value): self.RfrdDocInf.append(value)
    def insert_RfrdDocInf_at(self, index, value): self.RfrdDocInf.insert(index, value)
    def replace_RfrdDocInf_at(self, index, value): self.RfrdDocInf[index] = value
    def get_RfrdDocAmt(self): return self.RfrdDocAmt
    def set_RfrdDocAmt(self, RfrdDocAmt): self.RfrdDocAmt = RfrdDocAmt
    def get_CdtrRefInf(self): return self.CdtrRefInf
    def set_CdtrRefInf(self, CdtrRefInf): self.CdtrRefInf = CdtrRefInf
    def get_Invcr(self): return self.Invcr
    def set_Invcr(self, Invcr): self.Invcr = Invcr
    def get_Invcee(self): return self.Invcee
    def set_Invcee(self, Invcee): self.Invcee = Invcee
    def get_AddtlRmtInf(self): return self.AddtlRmtInf
    def set_AddtlRmtInf(self, AddtlRmtInf): self.AddtlRmtInf = AddtlRmtInf
    def add_AddtlRmtInf(self, value): self.AddtlRmtInf.append(value)
    def insert_AddtlRmtInf_at(self, index, value): self.AddtlRmtInf.insert(index, value)
    def replace_AddtlRmtInf_at(self, index, value): self.AddtlRmtInf[index] = value
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on BasicText-CH.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_Max140Text_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max140Text_patterns_, ))
    validate_Max140Text_patterns_ = [[u'^([a-zA-Z0-9\\.,;:\'\\+\\-/\\(\\)?\\*\\[\\]\\{\\}\\\\`\xb4~ ]|[!"#%&<>\xf7=@_$\xa3]|[\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xfd\xdf\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xd1])*$']]
    def hasContent_(self):
        if (
            self.RfrdDocInf or
            self.RfrdDocAmt is not None or
            self.CdtrRefInf is not None or
            self.Invcr is not None or
            self.Invcee is not None or
            self.AddtlRmtInf
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StructuredRemittanceInformation7', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructuredRemittanceInformation7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StructuredRemittanceInformation7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StructuredRemittanceInformation7'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StructuredRemittanceInformation7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RfrdDocInf_ in self.RfrdDocInf:
            RfrdDocInf_.export(outfile, level, namespace_, name_='RfrdDocInf', pretty_print=pretty_print)
        if self.RfrdDocAmt is not None:
            self.RfrdDocAmt.export(outfile, level, namespace_, name_='RfrdDocAmt', pretty_print=pretty_print)
        if self.CdtrRefInf is not None:
            self.CdtrRefInf.export(outfile, level, namespace_, name_='CdtrRefInf', pretty_print=pretty_print)
        if self.Invcr is not None:
            self.Invcr.export(outfile, level, namespace_, name_='Invcr', pretty_print=pretty_print)
        if self.Invcee is not None:
            self.Invcee.export(outfile, level, namespace_, name_='Invcee', pretty_print=pretty_print)
        for AddtlRmtInf_ in self.AddtlRmtInf:
            AddtlRmtInf_.export(outfile, level, namespace_, name_='AddtlRmtInf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RfrdDocInf':
            obj_ = ReferredDocumentInformation3.factory()
            obj_.build(child_)
            self.RfrdDocInf.append(obj_)
            obj_.original_tagname_ = 'RfrdDocInf'
        elif nodeName_ == 'RfrdDocAmt':
            obj_ = RemittanceAmount1.factory()
            obj_.build(child_)
            self.RfrdDocAmt = obj_
            obj_.original_tagname_ = 'RfrdDocAmt'
        elif nodeName_ == 'CdtrRefInf':
            obj_ = CreditorReferenceInformation2.factory()
            obj_.build(child_)
            self.CdtrRefInf = obj_
            obj_.original_tagname_ = 'CdtrRefInf'
        elif nodeName_ == 'Invcr':
            obj_ = PartyIdentification32.factory()
            obj_.build(child_)
            self.Invcr = obj_
            obj_.original_tagname_ = 'Invcr'
        elif nodeName_ == 'Invcee':
            obj_ = PartyIdentification32.factory()
            obj_.build(child_)
            self.Invcee = obj_
            obj_.original_tagname_ = 'Invcee'
        elif nodeName_ == 'AddtlRmtInf':
            obj_ = None
            self.AddtlRmtInf.append(obj_)
            obj_.original_tagname_ = 'AddtlRmtInf'
            # validate type Max140Text
            self.validate_Max140Text(self.AddtlRmtInf[-1])
# end class StructuredRemittanceInformation7


GDSClassesMapping = {
    'AdjstmntAmtAndRsn': DocumentAdjustment1,
    'Amt': ActiveOrHistoricCurrencyAndAmount,
    'Authrty': RegulatoryAuthority2,
    'BrnchId': BranchData2,
    'CdOrPrtry': ReferredDocumentType1Choice,
    'CdtNoteAmt': ActiveOrHistoricCurrencyAndAmount,
    'CdtTrfTxInf': CreditTransferTransactionInformation10_CH,
    'Cdtr': PartyIdentification32_CH_Name,
    'CdtrAcct': CashAccount16_CH_Id,
    'CdtrAgt': BranchAndFinancialInstitutionIdentification4_CH,
    'CdtrRefInf': CreditorReferenceInformation2,
    'ChqInstr': Cheque6_CH,
    'ChrgsAcct': CashAccount16_CH_IdAndCurrency,
    'ClrSysId': ClearingSystemIdentification2Choice,
    'ClrSysMmbId': ClearingSystemMemberIdentification2,
    'CstmrCdtTrfInitn': CustomerCreditTransferInitiationV03_CH,
    'CtctDtls': ContactDetails2_CH,
    'CtgyPurp': CategoryPurpose1_CH_Code,
    'Dbtr': PartyIdentification32_CH,
    'DbtrAcct': CashAccount16_CH_IdTpCcy,
    'DbtrAgt': BranchAndFinancialInstitutionIdentification4_CH_BicOrClrId,
    'DlvryMtd': ChequeDeliveryMethod1Choice,
    'DscntApldAmt': ActiveOrHistoricCurrencyAndAmount,
    'DtAndPlcOfBirth': DateAndPlaceOfBirth,
    'Dtls': StructuredRegulatoryReporting3,
    'DuePyblAmt': ActiveOrHistoricCurrencyAndAmount,
    'EqvtAmt': EquivalentAmount2,
    'FinInstnId': FinancialInstitutionIdentification7_CH,
    'FwdgAgt': BranchAndFinancialInstitutionIdentification4,
    'GrpHdr': GroupHeader32_CH,
    'Id': Party6Choice_CH,
    'InitgPty': PartyIdentification32_CH_NameAndId,
    'InstdAmt': ActiveOrHistoricCurrencyAndAmount,
    'InstrForCdtrAgt': InstructionForCreditorAgent1,
    'IntrmyAgt1': BranchAndFinancialInstitutionIdentification4_CH,
    'Invcee': PartyIdentification32,
    'Invcr': PartyIdentification32,
    'LclInstrm': LocalInstrument2Choice,
    'OrgId': OrganisationIdentification4_CH,
    'Othr': GenericPersonIdentification1,
    'PmtId': PaymentIdentification1,
    'PmtInf': PaymentInstructionInformation3_CH,
    'PmtTpInf': PaymentTypeInformation19_CH,
    'PrvtId': PersonIdentification5_CH,
    'PstlAdr': PostalAddress6_CH,
    'Purp': Purpose2_CH_Code,
    'RfrdDocAmt': RemittanceAmount1,
    'RfrdDocInf': ReferredDocumentInformation3,
    'RgltryRptg': RegulatoryReporting3,
    'RmtInf': RemittanceInformation5_CH,
    'RmtdAmt': ActiveOrHistoricCurrencyAndAmount,
    'SchmeNm': PersonIdentificationSchemeName1Choice,
    'Strd': StructuredRemittanceInformation7,
    'SvcLvl': ServiceLevel8Choice,
    'TaxAmt': ActiveOrHistoricCurrencyAndAmount,
    'Tp': ReferredDocumentType2,
    'UltmtCdtr': PartyIdentification32_CH_Name,
    'UltmtDbtr': PartyIdentification32_CH,
    'XchgRateInf': ExchangeRateInformation1,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from pain001 import *\n\n')
        sys.stdout.write('import pain001 as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AccountIdentification4Choice_CH",
    "ActiveOrHistoricCurrencyAndAmount",
    "AmountType3Choice",
    "BranchAndFinancialInstitutionIdentification4",
    "BranchAndFinancialInstitutionIdentification4_CH",
    "BranchAndFinancialInstitutionIdentification4_CH_BicOrClrId",
    "BranchData2",
    "CashAccount16_CH_Id",
    "CashAccount16_CH_IdAndCurrency",
    "CashAccount16_CH_IdTpCcy",
    "CashAccountType2",
    "CategoryPurpose1_CH_Code",
    "Cheque6_CH",
    "ChequeDeliveryMethod1Choice",
    "ClearingSystemIdentification2Choice",
    "ClearingSystemMemberIdentification2",
    "ContactDetails2",
    "ContactDetails2_CH",
    "CreditTransferTransactionInformation10_CH",
    "CreditorReferenceInformation2",
    "CreditorReferenceType1Choice",
    "CreditorReferenceType2",
    "CustomerCreditTransferInitiationV03_CH",
    "DateAndPlaceOfBirth",
    "Document",
    "DocumentAdjustment1",
    "EquivalentAmount2",
    "ExchangeRateInformation1",
    "FinancialIdentificationSchemeName1Choice",
    "FinancialInstitutionIdentification7",
    "FinancialInstitutionIdentification7_CH",
    "FinancialInstitutionIdentification7_CH_BicOrClrId",
    "GenericAccountIdentification1_CH",
    "GenericFinancialIdentification1",
    "GenericFinancialIdentification1_CH",
    "GenericOrganisationIdentification1",
    "GenericPersonIdentification1",
    "GroupHeader32_CH",
    "InstructionForCreditorAgent1",
    "LocalInstrument2Choice",
    "OrganisationIdentification4",
    "OrganisationIdentification4_CH",
    "OrganisationIdentificationSchemeName1Choice",
    "Party6Choice",
    "Party6Choice_CH",
    "PartyIdentification32",
    "PartyIdentification32_CH",
    "PartyIdentification32_CH_Name",
    "PartyIdentification32_CH_NameAndId",
    "PaymentIdentification1",
    "PaymentInstructionInformation3_CH",
    "PaymentTypeInformation19_CH",
    "PersonIdentification5",
    "PersonIdentification5_CH",
    "PersonIdentificationSchemeName1Choice",
    "PostalAddress6",
    "PostalAddress6_CH",
    "Purpose2_CH_Code",
    "ReferredDocumentInformation3",
    "ReferredDocumentType1Choice",
    "ReferredDocumentType2",
    "RegulatoryAuthority2",
    "RegulatoryReporting3",
    "RemittanceAmount1",
    "RemittanceInformation5_CH",
    "ServiceLevel8Choice",
    "StructuredRegulatoryReporting3",
    "StructuredRemittanceInformation7"
]
